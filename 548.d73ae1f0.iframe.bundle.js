"use strict";(self.webpackChunkfluent_ui_v9=self.webpackChunkfluent_ui_v9||[]).push([[548],{"./node_modules/@fluentui/keyboard-keys/lib/keys.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$xS:()=>Space,DoI:()=>ArrowUp,Er0:()=>Backspace,Qpb:()=>ArrowRight,e5x:()=>PageDown,j0c:()=>PageUp,nkM:()=>ArrowLeft,oam:()=>End,ozo:()=>Tab,uf9:()=>Escape,vqc:()=>Shift,ww0:()=>Home,xyI:()=>Enter,yd$:()=>ArrowDown});const Shift="Shift",Enter="Enter",Space=" ",Tab="Tab",ArrowDown="ArrowDown",ArrowLeft="ArrowLeft",ArrowRight="ArrowRight",ArrowUp="ArrowUp",End="End",Home="Home",PageDown="PageDown",PageUp="PageUp",Backspace="Backspace",Escape="Escape"},"./node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>Portal});var react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),react_namespaceObject=__webpack_require__.t(react,2);function setVirtualParent(child,parent){if(!child)return;const virtualChild=child;virtualChild._virtual||(virtualChild._virtual={}),virtualChild._virtual.parent=parent}var isHTMLElement=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js");var ProviderContext=__webpack_require__("./node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js");const PortalMountNodeContext=react.createContext(void 0);PortalMountNodeContext.Provider;var ThemeClassNameContext=__webpack_require__("./node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js"),mergeClasses_esm=__webpack_require__("./node_modules/@griffel/core/mergeClasses.esm.js"),useFocusVisible=__webpack_require__("./node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js");const usePortalMountNodeStylesStyles=(0,__webpack_require__("./node_modules/@griffel/react/__styles.esm.js").X)({root:{qhf8xq:"f1euv43f",Bhzewxz:"f15twtuk",oyh7mz:["f1vgc2s3","f1e31b4d"],j35jbq:["f1e31b4d","f1vgc2s3"],Bj3rh1h:"f494woh"}},{d:[".f1euv43f{position:absolute;}",".f15twtuk{top:0;}",".f1vgc2s3{left:0;}",".f1e31b4d{right:0;}",".f494woh{z-index:1000000;}"]}),useInsertionEffect=react_namespaceObject.useInsertionEffect,usePortalMountNode_usePortalMountNode=options=>{const{targetDocument,dir}=(0,ProviderContext.Y)(),mountNode=function usePortalMountNode(){return react.useContext(PortalMountNodeContext)}(),focusVisibleRef=(0,useFocusVisible.Y)(),classes=usePortalMountNodeStylesStyles(),themeClassName=(0,ThemeClassNameContext.q)(),className=(0,mergeClasses_esm.z)(themeClassName,classes.root,options.className),targetNode=null!=mountNode?mountNode:null==targetDocument?void 0:targetDocument.body,element=function useDisposable(factory,deps){var _a;const useMemo4=react.useMemo,useEffect3=react.useEffect,[disposable,dispose]=null!=(_a=useMemo4((()=>factory()),deps))?_a:[null,()=>null];return useEffect3((()=>dispose),deps),disposable}((()=>{if(void 0===targetNode||options.disabled)return[null,()=>null];const newElement=targetNode.ownerDocument.createElement("div");return targetNode.appendChild(newElement),[newElement,()=>newElement.remove()]}),[targetNode]);return useInsertionEffect?useInsertionEffect((()=>{if(!element)return;const classesToApply=className.split(" ").filter(Boolean);return element.classList.add(...classesToApply),element.setAttribute("dir",dir),element.setAttribute("data-portal-node","true"),focusVisibleRef.current=element,()=>{element.classList.remove(...classesToApply),element.removeAttribute("dir")}}),[className,dir,element,focusVisibleRef]):react.useMemo((()=>{element&&(element.className=className,element.setAttribute("dir",dir),element.setAttribute("data-portal-node","true"),focusVisibleRef.current=element)}),[className,dir,element,focusVisibleRef]),element},usePortal_unstable=props=>{const{element,className}=function toMountNodeProps(mountNode){return(0,isHTMLElement.s)(mountNode)?{element:mountNode}:"object"==typeof mountNode?null===mountNode?{element:null}:mountNode:{}}(props.mountNode),virtualParentRootRef=react.useRef(null),fallbackElement=usePortalMountNode_usePortalMountNode({disabled:!!element,className}),mountNode=null!=element?element:fallbackElement,state={children:props.children,mountNode,virtualParentRootRef};return react.useEffect((()=>{if(!mountNode)return;const virtualParent=virtualParentRootRef.current,isVirtualParentInsideChild=mountNode.contains(virtualParent);return virtualParent&&!isVirtualParentInsideChild?(setVirtualParent(mountNode,virtualParent),()=>{setVirtualParent(mountNode,void 0)}):void 0}),[virtualParentRootRef,mountNode]),state};var react_dom=__webpack_require__("./node_modules/next/dist/compiled/react-dom/index.js");const Portal=props=>(state=>react.createElement("span",{hidden:!0,ref:state.virtualParentRootRef},state.mountNode&&react_dom.createPortal(state.children,state.mountNode)))(usePortal_unstable(props));Portal.displayName="Portal"},"./node_modules/@fluentui/react-positioning/lib/usePositioning.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{T:()=>usePositioning});const sides=["top","right","bottom","left"],floating_ui_utils_min=Math.min,floating_ui_utils_max=Math.max,round=Math.round,createCoords=(Math.floor,v=>({x:v,y:v})),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp(start,value,end){return floating_ui_utils_max(start,floating_ui_utils_min(value,end))}function floating_ui_utils_evaluate(value,param){return"function"==typeof value?value(param):value}function floating_ui_utils_getSide(placement){return placement.split("-")[0]}function floating_ui_utils_getAlignment(placement){return placement.split("-")[1]}function getOppositeAxis(axis){return"x"===axis?"y":"x"}function getAxisLength(axis){return"y"===axis?"height":"width"}function floating_ui_utils_getSideAxis(placement){return["top","bottom"].includes(floating_ui_utils_getSide(placement))?"y":"x"}function getAlignmentAxis(placement){return getOppositeAxis(floating_ui_utils_getSideAxis(placement))}function floating_ui_utils_getOppositeAlignmentPlacement(placement){return placement.replace(/start|end/g,(alignment=>oppositeAlignmentMap[alignment]))}function getOppositePlacement(placement){return placement.replace(/left|right|bottom|top/g,(side=>oppositeSideMap[side]))}function floating_ui_utils_getPaddingObject(padding){return"number"!=typeof padding?function expandPaddingObject(padding){return{top:0,right:0,bottom:0,left:0,...padding}}(padding):{top:padding,right:padding,bottom:padding,left:padding}}function floating_ui_utils_rectToClientRect(rect){const{x,y,width,height}=rect;return{width,height,top:y,left:x,right:x+width,bottom:y+height,x,y}}function computeCoordsFromPlacement(_ref,placement,rtl){let{reference,floating}=_ref;const sideAxis=floating_ui_utils_getSideAxis(placement),alignmentAxis=getAlignmentAxis(placement),alignLength=getAxisLength(alignmentAxis),side=floating_ui_utils_getSide(placement),isVertical="y"===sideAxis,commonX=reference.x+reference.width/2-floating.width/2,commonY=reference.y+reference.height/2-floating.height/2,commonAlign=reference[alignLength]/2-floating[alignLength]/2;let coords;switch(side){case"top":coords={x:commonX,y:reference.y-floating.height};break;case"bottom":coords={x:commonX,y:reference.y+reference.height};break;case"right":coords={x:reference.x+reference.width,y:commonY};break;case"left":coords={x:reference.x-floating.width,y:commonY};break;default:coords={x:reference.x,y:reference.y}}switch(floating_ui_utils_getAlignment(placement)){case"start":coords[alignmentAxis]-=commonAlign*(rtl&&isVertical?-1:1);break;case"end":coords[alignmentAxis]+=commonAlign*(rtl&&isVertical?-1:1)}return coords}async function detectOverflow(state,options){var _await$platform$isEle;void 0===options&&(options={});const{x,y,platform,rects,elements,strategy}=state,{boundary="clippingAncestors",rootBoundary="viewport",elementContext="floating",altBoundary=!1,padding=0}=floating_ui_utils_evaluate(options,state),paddingObject=floating_ui_utils_getPaddingObject(padding),element=elements[altBoundary?"floating"===elementContext?"reference":"floating":elementContext],clippingClientRect=floating_ui_utils_rectToClientRect(await platform.getClippingRect({element:null==(_await$platform$isEle=await(null==platform.isElement?void 0:platform.isElement(element)))||_await$platform$isEle?element:element.contextElement||await(null==platform.getDocumentElement?void 0:platform.getDocumentElement(elements.floating)),boundary,rootBoundary,strategy})),rect="floating"===elementContext?{x,y,width:rects.floating.width,height:rects.floating.height}:rects.reference,offsetParent=await(null==platform.getOffsetParent?void 0:platform.getOffsetParent(elements.floating)),offsetScale=await(null==platform.isElement?void 0:platform.isElement(offsetParent))&&await(null==platform.getScale?void 0:platform.getScale(offsetParent))||{x:1,y:1},elementClientRect=floating_ui_utils_rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect?await platform.convertOffsetParentRelativeRectToViewportRelativeRect({elements,rect,offsetParent,strategy}):rect);return{top:(clippingClientRect.top-elementClientRect.top+paddingObject.top)/offsetScale.y,bottom:(elementClientRect.bottom-clippingClientRect.bottom+paddingObject.bottom)/offsetScale.y,left:(clippingClientRect.left-elementClientRect.left+paddingObject.left)/offsetScale.x,right:(elementClientRect.right-clippingClientRect.right+paddingObject.right)/offsetScale.x}}function getSideOffsets(overflow,rect){return{top:overflow.top-rect.height,right:overflow.right-rect.width,bottom:overflow.bottom-rect.height,left:overflow.left-rect.width}}function isAnySideFullyClipped(overflow){return sides.some((side=>overflow[side]>=0))}function hasWindow(){return"undefined"!=typeof window}function getNodeName(node){return isNode(node)?(node.nodeName||"").toLowerCase():"#document"}function getWindow(node){var _node$ownerDocument;return(null==node||null==(_node$ownerDocument=node.ownerDocument)?void 0:_node$ownerDocument.defaultView)||window}function floating_ui_utils_dom_getDocumentElement(node){var _ref;return null==(_ref=(isNode(node)?node.ownerDocument:node.document)||window.document)?void 0:_ref.documentElement}function isNode(value){return!!hasWindow()&&(value instanceof Node||value instanceof getWindow(value).Node)}function isElement(value){return!!hasWindow()&&(value instanceof Element||value instanceof getWindow(value).Element)}function isHTMLElement(value){return!!hasWindow()&&(value instanceof HTMLElement||value instanceof getWindow(value).HTMLElement)}function isShadowRoot(value){return!(!hasWindow()||"undefined"==typeof ShadowRoot)&&(value instanceof ShadowRoot||value instanceof getWindow(value).ShadowRoot)}function isOverflowElement(element){const{overflow,overflowX,overflowY,display}=getComputedStyle(element);return/auto|scroll|overlay|hidden|clip/.test(overflow+overflowY+overflowX)&&!["inline","contents"].includes(display)}function isTableElement(element){return["table","td","th"].includes(getNodeName(element))}function isTopLayer(element){return[":popover-open",":modal"].some((selector=>{try{return element.matches(selector)}catch(e){return!1}}))}function isContainingBlock(elementOrCss){const webkit=isWebKit(),css=isElement(elementOrCss)?getComputedStyle(elementOrCss):elementOrCss;return"none"!==css.transform||"none"!==css.perspective||!!css.containerType&&"normal"!==css.containerType||!webkit&&!!css.backdropFilter&&"none"!==css.backdropFilter||!webkit&&!!css.filter&&"none"!==css.filter||["transform","perspective","filter"].some((value=>(css.willChange||"").includes(value)))||["paint","layout","strict","content"].some((value=>(css.contain||"").includes(value)))}function isWebKit(){return!("undefined"==typeof CSS||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(node){return["html","body","#document"].includes(getNodeName(node))}function getComputedStyle(element){return getWindow(element).getComputedStyle(element)}function getNodeScroll(element){return isElement(element)?{scrollLeft:element.scrollLeft,scrollTop:element.scrollTop}:{scrollLeft:element.scrollX,scrollTop:element.scrollY}}function getParentNode(node){if("html"===getNodeName(node))return node;const result=node.assignedSlot||node.parentNode||isShadowRoot(node)&&node.host||floating_ui_utils_dom_getDocumentElement(node);return isShadowRoot(result)?result.host:result}function getNearestOverflowAncestor(node){const parentNode=getParentNode(node);return isLastTraversableNode(parentNode)?node.ownerDocument?node.ownerDocument.body:node.body:isHTMLElement(parentNode)&&isOverflowElement(parentNode)?parentNode:getNearestOverflowAncestor(parentNode)}function floating_ui_utils_dom_getOverflowAncestors(node,list,traverseIframes){var _node$ownerDocument2;void 0===list&&(list=[]),void 0===traverseIframes&&(traverseIframes=!0);const scrollableAncestor=getNearestOverflowAncestor(node),isBody=scrollableAncestor===(null==(_node$ownerDocument2=node.ownerDocument)?void 0:_node$ownerDocument2.body),win=getWindow(scrollableAncestor);if(isBody){const frameElement=getFrameElement(win);return list.concat(win,win.visualViewport||[],isOverflowElement(scrollableAncestor)?scrollableAncestor:[],frameElement&&traverseIframes?floating_ui_utils_dom_getOverflowAncestors(frameElement):[])}return list.concat(scrollableAncestor,floating_ui_utils_dom_getOverflowAncestors(scrollableAncestor,[],traverseIframes))}function getFrameElement(win){return win.parent&&Object.getPrototypeOf(win.parent)?win.frameElement:null}function getCssDimensions(element){const css=getComputedStyle(element);let width=parseFloat(css.width)||0,height=parseFloat(css.height)||0;const hasOffset=isHTMLElement(element),offsetWidth=hasOffset?element.offsetWidth:width,offsetHeight=hasOffset?element.offsetHeight:height,shouldFallback=round(width)!==offsetWidth||round(height)!==offsetHeight;return shouldFallback&&(width=offsetWidth,height=offsetHeight),{width,height,$:shouldFallback}}function unwrapElement(element){return isElement(element)?element:element.contextElement}function getScale(element){const domElement=unwrapElement(element);if(!isHTMLElement(domElement))return createCoords(1);const rect=domElement.getBoundingClientRect(),{width,height,$}=getCssDimensions(domElement);let x=($?round(rect.width):rect.width)/width,y=($?round(rect.height):rect.height)/height;return x&&Number.isFinite(x)||(x=1),y&&Number.isFinite(y)||(y=1),{x,y}}const noOffsets=createCoords(0);function getVisualOffsets(element){const win=getWindow(element);return isWebKit()&&win.visualViewport?{x:win.visualViewport.offsetLeft,y:win.visualViewport.offsetTop}:noOffsets}function getBoundingClientRect(element,includeScale,isFixedStrategy,offsetParent){void 0===includeScale&&(includeScale=!1),void 0===isFixedStrategy&&(isFixedStrategy=!1);const clientRect=element.getBoundingClientRect(),domElement=unwrapElement(element);let scale=createCoords(1);includeScale&&(offsetParent?isElement(offsetParent)&&(scale=getScale(offsetParent)):scale=getScale(element));const visualOffsets=function shouldAddVisualOffsets(element,isFixed,floatingOffsetParent){return void 0===isFixed&&(isFixed=!1),!(!floatingOffsetParent||isFixed&&floatingOffsetParent!==getWindow(element))&&isFixed}(domElement,isFixedStrategy,offsetParent)?getVisualOffsets(domElement):createCoords(0);let x=(clientRect.left+visualOffsets.x)/scale.x,y=(clientRect.top+visualOffsets.y)/scale.y,width=clientRect.width/scale.x,height=clientRect.height/scale.y;if(domElement){const win=getWindow(domElement),offsetWin=offsetParent&&isElement(offsetParent)?getWindow(offsetParent):offsetParent;let currentWin=win,currentIFrame=getFrameElement(currentWin);for(;currentIFrame&&offsetParent&&offsetWin!==currentWin;){const iframeScale=getScale(currentIFrame),iframeRect=currentIFrame.getBoundingClientRect(),css=getComputedStyle(currentIFrame),left=iframeRect.left+(currentIFrame.clientLeft+parseFloat(css.paddingLeft))*iframeScale.x,top=iframeRect.top+(currentIFrame.clientTop+parseFloat(css.paddingTop))*iframeScale.y;x*=iframeScale.x,y*=iframeScale.y,width*=iframeScale.x,height*=iframeScale.y,x+=left,y+=top,currentWin=getWindow(currentIFrame),currentIFrame=getFrameElement(currentWin)}}return floating_ui_utils_rectToClientRect({width,height,x,y})}function getWindowScrollBarX(element,rect){const leftScroll=getNodeScroll(element).scrollLeft;return rect?rect.left+leftScroll:getBoundingClientRect(floating_ui_utils_dom_getDocumentElement(element)).left+leftScroll}function getHTMLOffset(documentElement,scroll,ignoreScrollbarX){void 0===ignoreScrollbarX&&(ignoreScrollbarX=!1);const htmlRect=documentElement.getBoundingClientRect();return{x:htmlRect.left+scroll.scrollLeft-(ignoreScrollbarX?0:getWindowScrollBarX(documentElement,htmlRect)),y:htmlRect.top+scroll.scrollTop}}function getClientRectFromClippingAncestor(element,clippingAncestor,strategy){let rect;if("viewport"===clippingAncestor)rect=function getViewportRect(element,strategy){const win=getWindow(element),html=floating_ui_utils_dom_getDocumentElement(element),visualViewport=win.visualViewport;let width=html.clientWidth,height=html.clientHeight,x=0,y=0;if(visualViewport){width=visualViewport.width,height=visualViewport.height;const visualViewportBased=isWebKit();(!visualViewportBased||visualViewportBased&&"fixed"===strategy)&&(x=visualViewport.offsetLeft,y=visualViewport.offsetTop)}return{width,height,x,y}}(element,strategy);else if("document"===clippingAncestor)rect=function getDocumentRect(element){const html=floating_ui_utils_dom_getDocumentElement(element),scroll=getNodeScroll(element),body=element.ownerDocument.body,width=floating_ui_utils_max(html.scrollWidth,html.clientWidth,body.scrollWidth,body.clientWidth),height=floating_ui_utils_max(html.scrollHeight,html.clientHeight,body.scrollHeight,body.clientHeight);let x=-scroll.scrollLeft+getWindowScrollBarX(element);const y=-scroll.scrollTop;return"rtl"===getComputedStyle(body).direction&&(x+=floating_ui_utils_max(html.clientWidth,body.clientWidth)-width),{width,height,x,y}}(floating_ui_utils_dom_getDocumentElement(element));else if(isElement(clippingAncestor))rect=function getInnerBoundingClientRect(element,strategy){const clientRect=getBoundingClientRect(element,!0,"fixed"===strategy),top=clientRect.top+element.clientTop,left=clientRect.left+element.clientLeft,scale=isHTMLElement(element)?getScale(element):createCoords(1);return{width:element.clientWidth*scale.x,height:element.clientHeight*scale.y,x:left*scale.x,y:top*scale.y}}(clippingAncestor,strategy);else{const visualOffsets=getVisualOffsets(element);rect={x:clippingAncestor.x-visualOffsets.x,y:clippingAncestor.y-visualOffsets.y,width:clippingAncestor.width,height:clippingAncestor.height}}return floating_ui_utils_rectToClientRect(rect)}function hasFixedPositionAncestor(element,stopNode){const parentNode=getParentNode(element);return!(parentNode===stopNode||!isElement(parentNode)||isLastTraversableNode(parentNode))&&("fixed"===getComputedStyle(parentNode).position||hasFixedPositionAncestor(parentNode,stopNode))}function getRectRelativeToOffsetParent(element,offsetParent,strategy){const isOffsetParentAnElement=isHTMLElement(offsetParent),documentElement=floating_ui_utils_dom_getDocumentElement(offsetParent),isFixed="fixed"===strategy,rect=getBoundingClientRect(element,!0,isFixed,offsetParent);let scroll={scrollLeft:0,scrollTop:0};const offsets=createCoords(0);if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed)if(("body"!==getNodeName(offsetParent)||isOverflowElement(documentElement))&&(scroll=getNodeScroll(offsetParent)),isOffsetParentAnElement){const offsetRect=getBoundingClientRect(offsetParent,!0,isFixed,offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft,offsets.y=offsetRect.y+offsetParent.clientTop}else documentElement&&(offsets.x=getWindowScrollBarX(documentElement));const htmlOffset=!documentElement||isOffsetParentAnElement||isFixed?createCoords(0):getHTMLOffset(documentElement,scroll);return{x:rect.left+scroll.scrollLeft-offsets.x-htmlOffset.x,y:rect.top+scroll.scrollTop-offsets.y-htmlOffset.y,width:rect.width,height:rect.height}}function isStaticPositioned(element){return"static"===getComputedStyle(element).position}function getTrueOffsetParent(element,polyfill){if(!isHTMLElement(element)||"fixed"===getComputedStyle(element).position)return null;if(polyfill)return polyfill(element);let rawOffsetParent=element.offsetParent;return floating_ui_utils_dom_getDocumentElement(element)===rawOffsetParent&&(rawOffsetParent=rawOffsetParent.ownerDocument.body),rawOffsetParent}function getOffsetParent(element,polyfill){const win=getWindow(element);if(isTopLayer(element))return win;if(!isHTMLElement(element)){let svgOffsetParent=getParentNode(element);for(;svgOffsetParent&&!isLastTraversableNode(svgOffsetParent);){if(isElement(svgOffsetParent)&&!isStaticPositioned(svgOffsetParent))return svgOffsetParent;svgOffsetParent=getParentNode(svgOffsetParent)}return win}let offsetParent=getTrueOffsetParent(element,polyfill);for(;offsetParent&&isTableElement(offsetParent)&&isStaticPositioned(offsetParent);)offsetParent=getTrueOffsetParent(offsetParent,polyfill);return offsetParent&&isLastTraversableNode(offsetParent)&&isStaticPositioned(offsetParent)&&!isContainingBlock(offsetParent)?win:offsetParent||function getContainingBlock(element){let currentNode=getParentNode(element);for(;isHTMLElement(currentNode)&&!isLastTraversableNode(currentNode);){if(isContainingBlock(currentNode))return currentNode;if(isTopLayer(currentNode))return null;currentNode=getParentNode(currentNode)}return null}(element)||win}const platform={convertOffsetParentRelativeRectToViewportRelativeRect:function convertOffsetParentRelativeRectToViewportRelativeRect(_ref){let{elements,rect,offsetParent,strategy}=_ref;const isFixed="fixed"===strategy,documentElement=floating_ui_utils_dom_getDocumentElement(offsetParent),topLayer=!!elements&&isTopLayer(elements.floating);if(offsetParent===documentElement||topLayer&&isFixed)return rect;let scroll={scrollLeft:0,scrollTop:0},scale=createCoords(1);const offsets=createCoords(0),isOffsetParentAnElement=isHTMLElement(offsetParent);if((isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed)&&(("body"!==getNodeName(offsetParent)||isOverflowElement(documentElement))&&(scroll=getNodeScroll(offsetParent)),isHTMLElement(offsetParent))){const offsetRect=getBoundingClientRect(offsetParent);scale=getScale(offsetParent),offsets.x=offsetRect.x+offsetParent.clientLeft,offsets.y=offsetRect.y+offsetParent.clientTop}const htmlOffset=!documentElement||isOffsetParentAnElement||isFixed?createCoords(0):getHTMLOffset(documentElement,scroll,!0);return{width:rect.width*scale.x,height:rect.height*scale.y,x:rect.x*scale.x-scroll.scrollLeft*scale.x+offsets.x+htmlOffset.x,y:rect.y*scale.y-scroll.scrollTop*scale.y+offsets.y+htmlOffset.y}},getDocumentElement:floating_ui_utils_dom_getDocumentElement,getClippingRect:function getClippingRect(_ref){let{element,boundary,rootBoundary,strategy}=_ref;const clippingAncestors=[..."clippingAncestors"===boundary?isTopLayer(element)?[]:function getClippingElementAncestors(element,cache){const cachedResult=cache.get(element);if(cachedResult)return cachedResult;let result=floating_ui_utils_dom_getOverflowAncestors(element,[],!1).filter((el=>isElement(el)&&"body"!==getNodeName(el))),currentContainingBlockComputedStyle=null;const elementIsFixed="fixed"===getComputedStyle(element).position;let currentNode=elementIsFixed?getParentNode(element):element;for(;isElement(currentNode)&&!isLastTraversableNode(currentNode);){const computedStyle=getComputedStyle(currentNode),currentNodeIsContaining=isContainingBlock(currentNode);currentNodeIsContaining||"fixed"!==computedStyle.position||(currentContainingBlockComputedStyle=null),(elementIsFixed?!currentNodeIsContaining&&!currentContainingBlockComputedStyle:!currentNodeIsContaining&&"static"===computedStyle.position&&currentContainingBlockComputedStyle&&["absolute","fixed"].includes(currentContainingBlockComputedStyle.position)||isOverflowElement(currentNode)&&!currentNodeIsContaining&&hasFixedPositionAncestor(element,currentNode))?result=result.filter((ancestor=>ancestor!==currentNode)):currentContainingBlockComputedStyle=computedStyle,currentNode=getParentNode(currentNode)}return cache.set(element,result),result}(element,this._c):[].concat(boundary),rootBoundary],firstClippingAncestor=clippingAncestors[0],clippingRect=clippingAncestors.reduce(((accRect,clippingAncestor)=>{const rect=getClientRectFromClippingAncestor(element,clippingAncestor,strategy);return accRect.top=floating_ui_utils_max(rect.top,accRect.top),accRect.right=floating_ui_utils_min(rect.right,accRect.right),accRect.bottom=floating_ui_utils_min(rect.bottom,accRect.bottom),accRect.left=floating_ui_utils_max(rect.left,accRect.left),accRect}),getClientRectFromClippingAncestor(element,firstClippingAncestor,strategy));return{width:clippingRect.right-clippingRect.left,height:clippingRect.bottom-clippingRect.top,x:clippingRect.left,y:clippingRect.top}},getOffsetParent,getElementRects:async function(data){const getOffsetParentFn=this.getOffsetParent||getOffsetParent,getDimensionsFn=this.getDimensions,floatingDimensions=await getDimensionsFn(data.floating);return{reference:getRectRelativeToOffsetParent(data.reference,await getOffsetParentFn(data.floating),data.strategy),floating:{x:0,y:0,width:floatingDimensions.width,height:floatingDimensions.height}}},getClientRects:function getClientRects(element){return Array.from(element.getClientRects())},getDimensions:function getDimensions(element){const{width,height}=getCssDimensions(element);return{width,height}},getScale,isElement,isRTL:function isRTL(element){return"rtl"===getComputedStyle(element).direction}};const floating_ui_dom_detectOverflow=detectOverflow,floating_ui_dom_offset=function(options){return void 0===options&&(options=0),{name:"offset",options,async fn(state){var _middlewareData$offse,_middlewareData$arrow;const{x,y,placement,middlewareData}=state,diffCoords=await async function convertValueToCoords(state,options){const{placement,platform,elements}=state,rtl=await(null==platform.isRTL?void 0:platform.isRTL(elements.floating)),side=floating_ui_utils_getSide(placement),alignment=floating_ui_utils_getAlignment(placement),isVertical="y"===floating_ui_utils_getSideAxis(placement),mainAxisMulti=["left","top"].includes(side)?-1:1,crossAxisMulti=rtl&&isVertical?-1:1,rawValue=floating_ui_utils_evaluate(options,state);let{mainAxis,crossAxis,alignmentAxis}="number"==typeof rawValue?{mainAxis:rawValue,crossAxis:0,alignmentAxis:null}:{mainAxis:rawValue.mainAxis||0,crossAxis:rawValue.crossAxis||0,alignmentAxis:rawValue.alignmentAxis};return alignment&&"number"==typeof alignmentAxis&&(crossAxis="end"===alignment?-1*alignmentAxis:alignmentAxis),isVertical?{x:crossAxis*crossAxisMulti,y:mainAxis*mainAxisMulti}:{x:mainAxis*mainAxisMulti,y:crossAxis*crossAxisMulti}}(state,options);return placement===(null==(_middlewareData$offse=middlewareData.offset)?void 0:_middlewareData$offse.placement)&&null!=(_middlewareData$arrow=middlewareData.arrow)&&_middlewareData$arrow.alignmentOffset?{}:{x:x+diffCoords.x,y:y+diffCoords.y,data:{...diffCoords,placement}}}}},floating_ui_dom_shift=function(options){return void 0===options&&(options={}),{name:"shift",options,async fn(state){const{x,y,placement}=state,{mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!1,limiter={fn:_ref=>{let{x,y}=_ref;return{x,y}}},...detectOverflowOptions}=floating_ui_utils_evaluate(options,state),coords={x,y},overflow=await detectOverflow(state,detectOverflowOptions),crossAxis=floating_ui_utils_getSideAxis(floating_ui_utils_getSide(placement)),mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis],crossAxisCoord=coords[crossAxis];if(checkMainAxis){const maxSide="y"===mainAxis?"bottom":"right";mainAxisCoord=clamp(mainAxisCoord+overflow["y"===mainAxis?"top":"left"],mainAxisCoord,mainAxisCoord-overflow[maxSide])}if(checkCrossAxis){const maxSide="y"===crossAxis?"bottom":"right";crossAxisCoord=clamp(crossAxisCoord+overflow["y"===crossAxis?"top":"left"],crossAxisCoord,crossAxisCoord-overflow[maxSide])}const limitedCoords=limiter.fn({...state,[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord});return{...limitedCoords,data:{x:limitedCoords.x-x,y:limitedCoords.y-y,enabled:{[mainAxis]:checkMainAxis,[crossAxis]:checkCrossAxis}}}}}},floating_ui_dom_flip=function(options){return void 0===options&&(options={}),{name:"flip",options,async fn(state){var _middlewareData$arrow,_middlewareData$flip;const{placement,middlewareData,rects,initialPlacement,platform,elements}=state,{mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!0,fallbackPlacements:specifiedFallbackPlacements,fallbackStrategy="bestFit",fallbackAxisSideDirection="none",flipAlignment=!0,...detectOverflowOptions}=floating_ui_utils_evaluate(options,state);if(null!=(_middlewareData$arrow=middlewareData.arrow)&&_middlewareData$arrow.alignmentOffset)return{};const side=floating_ui_utils_getSide(placement),initialSideAxis=floating_ui_utils_getSideAxis(initialPlacement),isBasePlacement=floating_ui_utils_getSide(initialPlacement)===initialPlacement,rtl=await(null==platform.isRTL?void 0:platform.isRTL(elements.floating)),fallbackPlacements=specifiedFallbackPlacements||(isBasePlacement||!flipAlignment?[getOppositePlacement(initialPlacement)]:function getExpandedPlacements(placement){const oppositePlacement=getOppositePlacement(placement);return[floating_ui_utils_getOppositeAlignmentPlacement(placement),oppositePlacement,floating_ui_utils_getOppositeAlignmentPlacement(oppositePlacement)]}(initialPlacement)),hasFallbackAxisSideDirection="none"!==fallbackAxisSideDirection;!specifiedFallbackPlacements&&hasFallbackAxisSideDirection&&fallbackPlacements.push(...function getOppositeAxisPlacements(placement,flipAlignment,direction,rtl){const alignment=floating_ui_utils_getAlignment(placement);let list=function getSideList(side,isStart,rtl){const lr=["left","right"],rl=["right","left"],tb=["top","bottom"],bt=["bottom","top"];switch(side){case"top":case"bottom":return rtl?isStart?rl:lr:isStart?lr:rl;case"left":case"right":return isStart?tb:bt;default:return[]}}(floating_ui_utils_getSide(placement),"start"===direction,rtl);return alignment&&(list=list.map((side=>side+"-"+alignment)),flipAlignment&&(list=list.concat(list.map(floating_ui_utils_getOppositeAlignmentPlacement)))),list}(initialPlacement,flipAlignment,fallbackAxisSideDirection,rtl));const placements=[initialPlacement,...fallbackPlacements],overflow=await detectOverflow(state,detectOverflowOptions),overflows=[];let overflowsData=(null==(_middlewareData$flip=middlewareData.flip)?void 0:_middlewareData$flip.overflows)||[];if(checkMainAxis&&overflows.push(overflow[side]),checkCrossAxis){const sides=function floating_ui_utils_getAlignmentSides(placement,rects,rtl){void 0===rtl&&(rtl=!1);const alignment=floating_ui_utils_getAlignment(placement),alignmentAxis=getAlignmentAxis(placement),length=getAxisLength(alignmentAxis);let mainAlignmentSide="x"===alignmentAxis?alignment===(rtl?"end":"start")?"right":"left":"start"===alignment?"bottom":"top";return rects.reference[length]>rects.floating[length]&&(mainAlignmentSide=getOppositePlacement(mainAlignmentSide)),[mainAlignmentSide,getOppositePlacement(mainAlignmentSide)]}(placement,rects,rtl);overflows.push(overflow[sides[0]],overflow[sides[1]])}if(overflowsData=[...overflowsData,{placement,overflows}],!overflows.every((side=>side<=0))){var _middlewareData$flip2,_overflowsData$filter;const nextIndex=((null==(_middlewareData$flip2=middlewareData.flip)?void 0:_middlewareData$flip2.index)||0)+1,nextPlacement=placements[nextIndex];if(nextPlacement)return{data:{index:nextIndex,overflows:overflowsData},reset:{placement:nextPlacement}};let resetPlacement=null==(_overflowsData$filter=overflowsData.filter((d=>d.overflows[0]<=0)).sort(((a,b)=>a.overflows[1]-b.overflows[1]))[0])?void 0:_overflowsData$filter.placement;if(!resetPlacement)switch(fallbackStrategy){case"bestFit":{var _overflowsData$filter2;const placement=null==(_overflowsData$filter2=overflowsData.filter((d=>{if(hasFallbackAxisSideDirection){const currentSideAxis=floating_ui_utils_getSideAxis(d.placement);return currentSideAxis===initialSideAxis||"y"===currentSideAxis}return!0})).map((d=>[d.placement,d.overflows.filter((overflow=>overflow>0)).reduce(((acc,overflow)=>acc+overflow),0)])).sort(((a,b)=>a[1]-b[1]))[0])?void 0:_overflowsData$filter2[0];placement&&(resetPlacement=placement);break}case"initialPlacement":resetPlacement=initialPlacement}if(placement!==resetPlacement)return{reset:{placement:resetPlacement}}}return{}}}},floating_ui_dom_size=function(options){return void 0===options&&(options={}),{name:"size",options,async fn(state){var _state$middlewareData,_state$middlewareData2;const{placement,rects,platform,elements}=state,{apply=()=>{},...detectOverflowOptions}=floating_ui_utils_evaluate(options,state),overflow=await detectOverflow(state,detectOverflowOptions),side=floating_ui_utils_getSide(placement),alignment=floating_ui_utils_getAlignment(placement),isYAxis="y"===floating_ui_utils_getSideAxis(placement),{width,height}=rects.floating;let heightSide,widthSide;"top"===side||"bottom"===side?(heightSide=side,widthSide=alignment===(await(null==platform.isRTL?void 0:platform.isRTL(elements.floating))?"start":"end")?"left":"right"):(widthSide=side,heightSide="end"===alignment?"top":"bottom");const maximumClippingHeight=height-overflow.top-overflow.bottom,maximumClippingWidth=width-overflow.left-overflow.right,overflowAvailableHeight=floating_ui_utils_min(height-overflow[heightSide],maximumClippingHeight),overflowAvailableWidth=floating_ui_utils_min(width-overflow[widthSide],maximumClippingWidth),noShift=!state.middlewareData.shift;let availableHeight=overflowAvailableHeight,availableWidth=overflowAvailableWidth;if(null!=(_state$middlewareData=state.middlewareData.shift)&&_state$middlewareData.enabled.x&&(availableWidth=maximumClippingWidth),null!=(_state$middlewareData2=state.middlewareData.shift)&&_state$middlewareData2.enabled.y&&(availableHeight=maximumClippingHeight),noShift&&!alignment){const xMin=floating_ui_utils_max(overflow.left,0),xMax=floating_ui_utils_max(overflow.right,0),yMin=floating_ui_utils_max(overflow.top,0),yMax=floating_ui_utils_max(overflow.bottom,0);isYAxis?availableWidth=width-2*(0!==xMin||0!==xMax?xMin+xMax:floating_ui_utils_max(overflow.left,overflow.right)):availableHeight=height-2*(0!==yMin||0!==yMax?yMin+yMax:floating_ui_utils_max(overflow.top,overflow.bottom))}await apply({...state,availableWidth,availableHeight});const nextDimensions=await platform.getDimensions(elements.floating);return width!==nextDimensions.width||height!==nextDimensions.height?{reset:{rects:!0}}:{}}}},floating_ui_dom_hide=function(options){return void 0===options&&(options={}),{name:"hide",options,async fn(state){const{rects}=state,{strategy="referenceHidden",...detectOverflowOptions}=floating_ui_utils_evaluate(options,state);switch(strategy){case"referenceHidden":{const offsets=getSideOffsets(await detectOverflow(state,{...detectOverflowOptions,elementContext:"reference"}),rects.reference);return{data:{referenceHiddenOffsets:offsets,referenceHidden:isAnySideFullyClipped(offsets)}}}case"escaped":{const offsets=getSideOffsets(await detectOverflow(state,{...detectOverflowOptions,altBoundary:!0}),rects.floating);return{data:{escapedOffsets:offsets,escaped:isAnySideFullyClipped(offsets)}}}default:return{}}}}},floating_ui_dom_arrow=options=>({name:"arrow",options,async fn(state){const{x,y,placement,rects,platform,elements,middlewareData}=state,{element,padding=0}=floating_ui_utils_evaluate(options,state)||{};if(null==element)return{};const paddingObject=floating_ui_utils_getPaddingObject(padding),coords={x,y},axis=getAlignmentAxis(placement),length=getAxisLength(axis),arrowDimensions=await platform.getDimensions(element),isYAxis="y"===axis,minProp=isYAxis?"top":"left",maxProp=isYAxis?"bottom":"right",clientProp=isYAxis?"clientHeight":"clientWidth",endDiff=rects.reference[length]+rects.reference[axis]-coords[axis]-rects.floating[length],startDiff=coords[axis]-rects.reference[axis],arrowOffsetParent=await(null==platform.getOffsetParent?void 0:platform.getOffsetParent(element));let clientSize=arrowOffsetParent?arrowOffsetParent[clientProp]:0;clientSize&&await(null==platform.isElement?void 0:platform.isElement(arrowOffsetParent))||(clientSize=elements.floating[clientProp]||rects.floating[length]);const centerToReference=endDiff/2-startDiff/2,largestPossiblePadding=clientSize/2-arrowDimensions[length]/2-1,minPadding=floating_ui_utils_min(paddingObject[minProp],largestPossiblePadding),maxPadding=floating_ui_utils_min(paddingObject[maxProp],largestPossiblePadding),min$1=minPadding,max=clientSize-arrowDimensions[length]-maxPadding,center=clientSize/2-arrowDimensions[length]/2+centerToReference,offset=clamp(min$1,center,max),shouldAddOffset=!middlewareData.arrow&&null!=floating_ui_utils_getAlignment(placement)&&center!==offset&&rects.reference[length]/2-(center<min$1?minPadding:maxPadding)-arrowDimensions[length]/2<0,alignmentOffset=shouldAddOffset?center<min$1?center-min$1:center-max:0;return{[axis]:coords[axis]+alignmentOffset,data:{[axis]:offset,centerOffset:center-offset-alignmentOffset,...shouldAddOffset&&{alignmentOffset}},reset:shouldAddOffset}}}),floating_ui_dom_limitShift=function(options){return void 0===options&&(options={}),{options,fn(state){const{x,y,placement,rects,middlewareData}=state,{offset=0,mainAxis:checkMainAxis=!0,crossAxis:checkCrossAxis=!0}=floating_ui_utils_evaluate(options,state),coords={x,y},crossAxis=floating_ui_utils_getSideAxis(placement),mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis],crossAxisCoord=coords[crossAxis];const rawOffset=floating_ui_utils_evaluate(offset,state),computedOffset="number"==typeof rawOffset?{mainAxis:rawOffset,crossAxis:0}:{mainAxis:0,crossAxis:0,...rawOffset};if(checkMainAxis){const len="y"===mainAxis?"height":"width",limitMin=rects.reference[mainAxis]-rects.floating[len]+computedOffset.mainAxis,limitMax=rects.reference[mainAxis]+rects.reference[len]-computedOffset.mainAxis;mainAxisCoord<limitMin?mainAxisCoord=limitMin:mainAxisCoord>limitMax&&(mainAxisCoord=limitMax)}if(checkCrossAxis){var _middlewareData$offse,_middlewareData$offse2;const len="y"===mainAxis?"width":"height",isOriginSide=["top","left"].includes(floating_ui_utils_getSide(placement)),limitMin=rects.reference[crossAxis]-rects.floating[len]+(isOriginSide&&(null==(_middlewareData$offse=middlewareData.offset)?void 0:_middlewareData$offse[crossAxis])||0)+(isOriginSide?0:computedOffset.crossAxis),limitMax=rects.reference[crossAxis]+rects.reference[len]+(isOriginSide?0:(null==(_middlewareData$offse2=middlewareData.offset)?void 0:_middlewareData$offse2[crossAxis])||0)-(isOriginSide?computedOffset.crossAxis:0);crossAxisCoord<limitMin?crossAxisCoord=limitMin:crossAxisCoord>limitMax&&(crossAxisCoord=limitMax)}return{[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord}}}},floating_ui_dom_computePosition=(reference,floating,options)=>{const cache=new Map,mergedOptions={platform,...options},platformWithCache={...mergedOptions.platform,_c:cache};return(async(reference,floating,config)=>{const{placement="bottom",strategy="absolute",middleware=[],platform}=config,validMiddleware=middleware.filter(Boolean),rtl=await(null==platform.isRTL?void 0:platform.isRTL(floating));let rects=await platform.getElementRects({reference,floating,strategy}),{x,y}=computeCoordsFromPlacement(rects,placement,rtl),statefulPlacement=placement,middlewareData={},resetCount=0;for(let i=0;i<validMiddleware.length;i++){const{name,fn}=validMiddleware[i],{x:nextX,y:nextY,data,reset}=await fn({x,y,initialPlacement:placement,placement:statefulPlacement,strategy,middlewareData,rects,platform,elements:{reference,floating}});x=null!=nextX?nextX:x,y=null!=nextY?nextY:y,middlewareData={...middlewareData,[name]:{...middlewareData[name],...data}},reset&&resetCount<=50&&(resetCount++,"object"==typeof reset&&(reset.placement&&(statefulPlacement=reset.placement),reset.rects&&(rects=!0===reset.rects?await platform.getElementRects({reference,floating,strategy}):reset.rects),({x,y}=computeCoordsFromPlacement(rects,statefulPlacement,rtl))),i=-1)}return{x,y,placement:statefulPlacement,strategy,middlewareData}})(reference,floating,{...mergedOptions,platform:platformWithCache})};var ProviderContext=__webpack_require__("./node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js"),canUseDOM=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js"),useEventCallback=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js"),useIsomorphicLayoutEffect=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js"),react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");function useCallbackRef(initialValue,callback,skipInitialResolve){const isFirst=react.useRef(!0),[ref]=react.useState((()=>({value:initialValue,callback,facade:{get current(){return ref.value},set current(value){const last=ref.value;if(last!==value){if(ref.value=value,skipInitialResolve&&isFirst.current)return;ref.callback(value,last)}}}})));return(0,useIsomorphicLayoutEffect.E)((()=>{isFirst.current=!1}),[]),ref.callback=callback,ref.facade}const normalizeAutoSize=autoSize=>{switch(autoSize){case"always":case!0:return{applyMaxWidth:!0,applyMaxHeight:!0};case"width-always":case"width":return{applyMaxWidth:!0,applyMaxHeight:!1};case"height-always":case"height":return{applyMaxWidth:!1,applyMaxHeight:!0};default:return!1}},getScrollParent=node=>{const parentNode=node&&(node=>"HTML"===node.nodeName?node:node.parentNode||node.host)(node);if(!parentNode)return document.body;switch(parentNode.nodeName){case"HTML":case"BODY":return parentNode.ownerDocument.body;case"#document":return parentNode.body}const{overflow,overflowX,overflowY}=(node=>{var _node_ownerDocument;return 1!==node.nodeType?{}:(null===(_node_ownerDocument=node.ownerDocument)||void 0===_node_ownerDocument?void 0:_node_ownerDocument.defaultView).getComputedStyle(node,null)})(parentNode);return/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)?parentNode:getScrollParent(parentNode)},hasScrollParent=node=>{var _scrollParentElement_ownerDocument;const scrollParentElement=getScrollParent(node);return!!scrollParentElement&&scrollParentElement!==(null===(_scrollParentElement_ownerDocument=scrollParentElement.ownerDocument)||void 0===_scrollParentElement_ownerDocument?void 0:_scrollParentElement_ownerDocument.body)},toFloatingUIPlacement=(align,position,rtl)=>{const alignment=((p,a)=>{const positionedVertically="above"===p||"below"===p,alignedVertically="top"===a||"bottom"===a;return positionedVertically&&alignedVertically||!positionedVertically&&!alignedVertically})(position,align)?"center":align,computedPosition=position&&(rtl=>({above:"top",below:"bottom",before:rtl?"right":"left",after:rtl?"left":"right"}))(rtl)[position],computedAlignment=alignment&&{start:"start",end:"end",top:"start",bottom:"end",center:void 0}[alignment];return computedPosition&&computedAlignment?`${computedPosition}-${computedAlignment}`:computedPosition};function getBoundary(element,boundary){if("window"===boundary)return null==element?void 0:element.ownerDocument.documentElement;if("clippingParents"===boundary)return"clippingAncestors";if("scrollParent"===boundary){let boundariesNode=getScrollParent(element);return"BODY"===boundariesNode.nodeName&&(boundariesNode=null==element?void 0:element.ownerDocument.documentElement),boundariesNode}return boundary}function toFloatingUIPadding(padding,isRtl){if("number"==typeof padding)return padding;const{start,end,...verticalPadding}=padding,paddingObject=verticalPadding,left=isRtl?"end":"start",right=isRtl?"start":"end";return padding[left]&&(paddingObject.left=padding[left]),padding[right]&&(paddingObject.right=padding[right]),paddingObject}const resetMaxSize=autoSize=>({name:"resetMaxSize",fn({middlewareData,elements}){var _middlewareData_resetMaxSize;if(null===(_middlewareData_resetMaxSize=middlewareData.resetMaxSize)||void 0===_middlewareData_resetMaxSize?void 0:_middlewareData_resetMaxSize.maxSizeAlreadyReset)return{};const{applyMaxWidth,applyMaxHeight}=autoSize;return applyMaxWidth&&(elements.floating.style.removeProperty("box-sizing"),elements.floating.style.removeProperty("max-width"),elements.floating.style.removeProperty("width")),applyMaxHeight&&(elements.floating.style.removeProperty("box-sizing"),elements.floating.style.removeProperty("max-height"),elements.floating.style.removeProperty("height")),{data:{maxSizeAlreadyReset:!0},reset:{rects:!0}}}});function maxSize(autoSize,options){const{container,overflowBoundary,overflowBoundaryPadding,isRtl}=options;return floating_ui_dom_size({...overflowBoundaryPadding&&{padding:toFloatingUIPadding(overflowBoundaryPadding,isRtl)},...overflowBoundary&&{altBoundary:!0,boundary:getBoundary(container,overflowBoundary)},apply({availableHeight,availableWidth,elements,rects}){const applyMaxSizeStyles=(apply,dimension,availableSize)=>{if(apply&&(elements.floating.style.setProperty("box-sizing","border-box"),elements.floating.style.setProperty(`max-${dimension}`,`${availableSize}px`),rects.floating[dimension]>availableSize)){elements.floating.style.setProperty(dimension,`${availableSize}px`);const axis="width"===dimension?"x":"y";elements.floating.style.getPropertyValue(`overflow-${axis}`)||elements.floating.style.setProperty(`overflow-${axis}`,"auto")}},{applyMaxWidth,applyMaxHeight}=autoSize;applyMaxSizeStyles(applyMaxWidth,"width",availableWidth),applyMaxSizeStyles(applyMaxHeight,"height",availableHeight)}})}const matchTargetSizeCssVar="--fui-match-target-size";function matchTargetSize_matchTargetSize(){return{name:"matchTargetSize",fn:async middlewareArguments=>{const{rects:{reference:referenceRect,floating:floatingRect},elements:{floating:floatingElement},middlewareData:{matchTargetSize:{matchTargetSizeAttempt=!1}={}}}=middlewareArguments;if(referenceRect.width===floatingRect.width||matchTargetSizeAttempt)return{};const{width}=referenceRect;return floatingElement.style.setProperty(matchTargetSizeCssVar,`${width}px`),floatingElement.style.width||(floatingElement.style.width=`var(${matchTargetSizeCssVar})`),{data:{matchTargetSizeAttempt:!0},reset:{rects:!0}}}}}function parseFloatingUIPlacement(placement){const tokens=placement.split("-");return{side:tokens[0],alignment:tokens[1]}}const fromFloatingUIPlacement=placement=>{const{side,alignment:floatingUIAlignment}=parseFloatingUIPlacement(placement),position={top:"above",bottom:"below",right:"after",left:"before"}[side],alignment=floatingUIAlignment&&(position=>"above"===position||"below"===position?{start:"start",end:"end"}:{start:"top",end:"bottom"})(position)[floatingUIAlignment];return{position,alignment}};function offset_offset(offsetValue){const floatingUIOffset=function getFloatingUIOffset(rawOffset){return rawOffset?"number"==typeof rawOffset||"object"==typeof rawOffset?rawOffset:({rects:{floating,reference},placement})=>{const{position,alignment}=fromFloatingUIPlacement(placement);return rawOffset({positionedRect:floating,targetRect:reference,position,alignment})}:rawOffset}(offsetValue);return floating_ui_dom_offset(floatingUIOffset)}function coverTarget_coverTarget(){return{name:"coverTarget",fn:middlewareArguments=>{const{placement,rects,x,y}=middlewareArguments,newCoords={x,y};switch(parseFloatingUIPlacement(placement).side){case"bottom":newCoords.y-=rects.reference.height;break;case"top":newCoords.y+=rects.reference.height;break;case"left":newCoords.x+=rects.reference.width;break;case"right":newCoords.x-=rects.reference.width}return newCoords}}}var resolvePositioningShorthand=__webpack_require__("./node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js");function flip_flip(options){const{hasScrollableElement,flipBoundary,container,fallbackPositions=[],isRtl}=options,fallbackPlacements=fallbackPositions.reduce(((acc,shorthand)=>{const{position,align}=(0,resolvePositioningShorthand.P)(shorthand),placement=toFloatingUIPlacement(align,position,isRtl);return placement&&acc.push(placement),acc}),[]);return floating_ui_dom_flip({...hasScrollableElement&&{boundary:"clippingAncestors"},...flipBoundary&&{altBoundary:!0,boundary:getBoundary(container,flipBoundary)},fallbackStrategy:"bestFit",...fallbackPlacements.length&&{fallbackPlacements}})}function shift_shift(options){const{hasScrollableElement,disableTether,overflowBoundary,container,overflowBoundaryPadding,isRtl}=options;return floating_ui_dom_shift({...hasScrollableElement&&{boundary:"clippingAncestors"},...disableTether&&{crossAxis:"all"===disableTether,limiter:floating_ui_dom_limitShift({crossAxis:"all"!==disableTether,mainAxis:!1})},...overflowBoundaryPadding&&{padding:toFloatingUIPadding(overflowBoundaryPadding,isRtl)},...overflowBoundary&&{altBoundary:!0,boundary:getBoundary(container,overflowBoundary)}})}function intersecting(){return{name:"intersectionObserver",fn:async middlewareArguments=>{const floatingRect=middlewareArguments.rects.floating,altOverflow=await floating_ui_dom_detectOverflow(middlewareArguments,{altBoundary:!0}),isIntersectingTop=altOverflow.top<floatingRect.height&&altOverflow.top>0,isIntersectingBottom=altOverflow.bottom<floatingRect.height&&altOverflow.bottom>0;return{data:{intersecting:isIntersectingTop||isIntersectingBottom}}}}}var utils_isHTMLElement=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js");const DATA_POSITIONING_INTERSECTING="data-popper-is-intersecting",DATA_POSITIONING_ESCAPED="data-popper-escaped",DATA_POSITIONING_HIDDEN="data-popper-reference-hidden",DATA_POSITIONING_PLACEMENT="data-popper-placement",POSITIONING_END_EVENT="fui-positioningend";function listScrollParents(node){const scrollParents=[];let cur=node;for(;cur;){const scrollParent=getScrollParent(cur);if(node.ownerDocument.body===scrollParent){scrollParents.push(scrollParent);break}if("BODY"===scrollParent.nodeName&&scrollParent!==node.ownerDocument.body){0;break}scrollParents.push(scrollParent),cur=scrollParent}return scrollParents}function createPositionManager(options){let isDestroyed=!1;const{container,target,arrow,strategy,middleware,placement,useTransform=!0,disableUpdateOnResize=!1}=options,targetWindow=container.ownerDocument.defaultView;if(!target||!container||!targetWindow)return{updatePosition:()=>{},dispose:()=>{}};const resizeObserver=disableUpdateOnResize?null:function createResizeObserver(targetWindow,callback){return new targetWindow.ResizeObserver(callback)}(targetWindow,(entries=>{entries.every((entry=>entry.contentRect.width>0&&entry.contentRect.height>0))&&updatePosition()}));let isFirstUpdate=!0;const scrollParents=new Set;Object.assign(container.style,{position:"fixed",left:0,top:0,margin:0});const forceUpdate=()=>{isDestroyed||(isFirstUpdate&&(listScrollParents(container).forEach((scrollParent=>scrollParents.add(scrollParent))),(0,utils_isHTMLElement.s)(target)&&listScrollParents(target).forEach((scrollParent=>scrollParents.add(scrollParent))),scrollParents.forEach((scrollParent=>{scrollParent.addEventListener("scroll",updatePosition,{passive:!0})})),null==resizeObserver||resizeObserver.observe(container),(0,utils_isHTMLElement.s)(target)&&(null==resizeObserver||resizeObserver.observe(target)),isFirstUpdate=!1),Object.assign(container.style,{position:strategy}),floating_ui_dom_computePosition(target,container,{placement,middleware,strategy}).then((({x,y,middlewareData,placement:computedPlacement})=>{isDestroyed||(!function writeArrowUpdates(options){const{arrow,middlewareData}=options;if(!middlewareData.arrow||!arrow)return;const{x:arrowX,y:arrowY}=middlewareData.arrow;Object.assign(arrow.style,{left:null!=arrowX?`${arrowX}px`:"",top:null!=arrowY?`${arrowY}px`:""})}({arrow,middlewareData}),function writeContainerUpdates(options){var _middlewareData_hide,_middlewareData_hide1,_container_ownerDocument_defaultView;const{container,placement,middlewareData,strategy,lowPPI,coordinates,useTransform=!0}=options;if(!container)return;container.setAttribute(DATA_POSITIONING_PLACEMENT,placement),container.removeAttribute(DATA_POSITIONING_INTERSECTING),middlewareData.intersectionObserver.intersecting&&container.setAttribute(DATA_POSITIONING_INTERSECTING,""),container.removeAttribute(DATA_POSITIONING_ESCAPED),(null===(_middlewareData_hide=middlewareData.hide)||void 0===_middlewareData_hide?void 0:_middlewareData_hide.escaped)&&container.setAttribute(DATA_POSITIONING_ESCAPED,""),container.removeAttribute(DATA_POSITIONING_HIDDEN),(null===(_middlewareData_hide1=middlewareData.hide)||void 0===_middlewareData_hide1?void 0:_middlewareData_hide1.referenceHidden)&&container.setAttribute(DATA_POSITIONING_HIDDEN,"");const devicePixelRatio=(null===(_container_ownerDocument_defaultView=container.ownerDocument.defaultView)||void 0===_container_ownerDocument_defaultView?void 0:_container_ownerDocument_defaultView.devicePixelRatio)||1,x=Math.round(coordinates.x*devicePixelRatio)/devicePixelRatio,y=Math.round(coordinates.y*devicePixelRatio)/devicePixelRatio;Object.assign(container.style,{position:strategy}),useTransform?Object.assign(container.style,{transform:lowPPI?`translate(${x}px, ${y}px)`:`translate3d(${x}px, ${y}px, 0)`}):Object.assign(container.style,{left:`${x}px`,top:`${y}px`})}({container,middlewareData,placement:computedPlacement,coordinates:{x,y},lowPPI:((null==targetWindow?void 0:targetWindow.devicePixelRatio)||1)<=1,strategy,useTransform}),container.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT)))})).catch((err=>{0})))},updatePosition=function debounce(fn){let pending;return()=>(pending||(pending=new Promise((resolve=>{Promise.resolve().then((()=>{pending=void 0,resolve(fn())}))}))),pending)}((()=>forceUpdate()));return targetWindow&&(targetWindow.addEventListener("scroll",updatePosition,{passive:!0}),targetWindow.addEventListener("resize",updatePosition)),updatePosition(),{updatePosition,dispose:()=>{isDestroyed=!0,targetWindow&&(targetWindow.removeEventListener("scroll",updatePosition),targetWindow.removeEventListener("resize",updatePosition)),scrollParents.forEach((scrollParent=>{scrollParent.removeEventListener("scroll",updatePosition)})),scrollParents.clear(),null==resizeObserver||resizeObserver.disconnect()}}}function usePositioning(options){const managerRef=react.useRef(null),targetRef=react.useRef(null),overrideTargetRef=react.useRef(null),containerRef=react.useRef(null),arrowRef=react.useRef(null),{enabled=!0}=options,resolvePositioningOptions=function usePositioningOptions(options){const{align,arrowPadding,autoSize:rawAutoSize,coverTarget,flipBoundary,offset,overflowBoundary,pinned,position,unstable_disableTether:disableTether,positionFixed,strategy,overflowBoundaryPadding,fallbackPositions,useTransform,matchTargetSize,disableUpdateOnResize=!1}=options,{dir,targetDocument}=(0,ProviderContext.Y)(),isRtl="rtl"===dir,positionStrategy=(null!=strategy?strategy:positionFixed)?"fixed":"absolute",autoSize=normalizeAutoSize(rawAutoSize);return react.useCallback(((container,arrow)=>{const hasScrollableElement=hasScrollParent(container),middleware=[autoSize&&resetMaxSize(autoSize),matchTargetSize&&matchTargetSize_matchTargetSize(),offset&&offset_offset(offset),coverTarget&&coverTarget_coverTarget(),!pinned&&flip_flip({container,flipBoundary,hasScrollableElement,isRtl,fallbackPositions}),shift_shift({container,hasScrollableElement,overflowBoundary,disableTether,overflowBoundaryPadding,isRtl}),autoSize&&maxSize(autoSize,{container,overflowBoundary,overflowBoundaryPadding,isRtl}),intersecting(),arrow&&floating_ui_dom_arrow({element:arrow,padding:arrowPadding}),floating_ui_dom_hide({strategy:"referenceHidden"}),floating_ui_dom_hide({strategy:"escaped"}),!1].filter(Boolean);return{placement:toFloatingUIPlacement(align,position,isRtl),middleware,strategy:positionStrategy,useTransform,disableUpdateOnResize}}),[align,arrowPadding,autoSize,coverTarget,disableTether,flipBoundary,isRtl,offset,overflowBoundary,pinned,position,positionStrategy,overflowBoundaryPadding,fallbackPositions,useTransform,matchTargetSize,targetDocument,disableUpdateOnResize])}(options),updatePositionManager=react.useCallback((()=>{var _overrideTargetRef_current;managerRef.current&&managerRef.current.dispose(),managerRef.current=null;const target=null!==(_overrideTargetRef_current=overrideTargetRef.current)&&void 0!==_overrideTargetRef_current?_overrideTargetRef_current:targetRef.current;enabled&&(0,canUseDOM.S)()&&target&&containerRef.current&&(managerRef.current=createPositionManager({container:containerRef.current,target,arrow:arrowRef.current,...resolvePositioningOptions(containerRef.current,arrowRef.current)}))}),[enabled,resolvePositioningOptions]),setOverrideTarget=(0,useEventCallback.D)((target=>{overrideTargetRef.current=target,updatePositionManager()}));react.useImperativeHandle(options.positioningRef,(()=>({updatePosition:()=>{var _managerRef_current;return null===(_managerRef_current=managerRef.current)||void 0===_managerRef_current?void 0:_managerRef_current.updatePosition()},setTarget:target=>{options.target,setOverrideTarget(target)}})),[options.target,setOverrideTarget]),(0,useIsomorphicLayoutEffect.E)((()=>{var _options_target;setOverrideTarget(null!==(_options_target=options.target)&&void 0!==_options_target?_options_target:null)}),[options.target,setOverrideTarget]),(0,useIsomorphicLayoutEffect.E)((()=>{updatePositionManager()}),[updatePositionManager]);const setTarget=useCallbackRef(null,(target=>{targetRef.current!==target&&(targetRef.current=target,updatePositionManager())})),onPositioningEnd=(0,useEventCallback.D)((()=>{var _options_onPositioningEnd;return null===(_options_onPositioningEnd=options.onPositioningEnd)||void 0===_options_onPositioningEnd?void 0:_options_onPositioningEnd.call(options)})),setContainer=useCallbackRef(null,(container=>{var _containerRef_current;containerRef.current!==container&&(null===(_containerRef_current=containerRef.current)||void 0===_containerRef_current||_containerRef_current.removeEventListener(POSITIONING_END_EVENT,onPositioningEnd),null==container||container.addEventListener(POSITIONING_END_EVENT,onPositioningEnd),containerRef.current=container,updatePositionManager())})),setArrow=useCallbackRef(null,(arrow=>{arrowRef.current!==arrow&&(arrowRef.current=arrow,updatePositionManager())}));return{targetRef:setTarget,containerRef:setContainer,arrowRef:setArrow}}},"./node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{P:()=>resolvePositioningShorthand});const shorthandLookup={above:{position:"above",align:"center"},"above-start":{position:"above",align:"start"},"above-end":{position:"above",align:"end"},below:{position:"below",align:"center"},"below-start":{position:"below",align:"start"},"below-end":{position:"below",align:"end"},before:{position:"before",align:"center"},"before-top":{position:"before",align:"top"},"before-bottom":{position:"before",align:"bottom"},after:{position:"after",align:"center"},"after-top":{position:"after",align:"top"},"after-bottom":{position:"after",align:"bottom"}};function resolvePositioningShorthand(shorthand){return null==shorthand?{}:"string"==typeof shorthand?shorthandLookup[shorthand]:shorthand}},"./node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{i:()=>useControllableState});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");const useControllableState=options=>{const[internalState,setInternalState]=react__WEBPACK_IMPORTED_MODULE_0__.useState((()=>void 0===options.defaultState?options.initialState:function isInitializer(value){return"function"==typeof value}(options.defaultState)?options.defaultState():options.defaultState)),stateValueRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(options.state);react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{stateValueRef.current=options.state}),[options.state]);const setControlledState=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState=>{(function isFactoryDispatch(newState){return"function"==typeof newState})(newState)&&newState(stateValueRef.current)}),[]);return useIsControlled(options.state)?[options.state,setControlledState]:[internalState,setInternalState]};const useIsControlled=controlledValue=>{const[isControlled]=react__WEBPACK_IMPORTED_MODULE_0__.useState((()=>void 0!==controlledValue));return isControlled}},"./node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{D:()=>useEventCallback});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js");const useEventCallback=fn=>{const callbackRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef((()=>{throw new Error("Cannot call an event handler while rendering")}));return(0,_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__.E)((()=>{callbackRef.current=fn}),[fn]),react__WEBPACK_IMPORTED_MODULE_0__.useCallback(((...args)=>(0,callbackRef.current)(...args)),[callbackRef])}},"./node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function mergeCallbacks(callback1,callback2){return(...args)=>{null==callback1||callback1(...args),null==callback2||callback2(...args)}}__webpack_require__.d(__webpack_exports__,{p:()=>mergeCallbacks})}}]);