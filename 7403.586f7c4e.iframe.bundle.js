/*! For license information please see 7403.586f7c4e.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkfluent_ui_v9=self.webpackChunkfluent_ui_v9||[]).push([[7403],{"./node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{p:()=>useTabster});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),_fluentui_react_shared_contexts__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js"),tabster__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/tabster/dist/tabster.esm.js"),_fluentui_react_utilities__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js"),_fluentui_react_utilities__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js");const useTabster=()=>{const{targetDocument}=(0,_fluentui_react_shared_contexts__WEBPACK_IMPORTED_MODULE_1__.Y)(),defaultView=(null==targetDocument?void 0:targetDocument.defaultView)||void 0,shadowDOMAPI=null==defaultView?void 0:defaultView.__tabsterShadowDOMAPI,tabster=react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>defaultView?(0,tabster__WEBPACK_IMPORTED_MODULE_2__._A)(defaultView,{autoRoot:{},controlTab:!1,getParent:_fluentui_react_utilities__WEBPACK_IMPORTED_MODULE_3__.P,checkUncontrolledTrappingFocus:element=>{var _element_firstElementChild;return!!(null===(_element_firstElementChild=element.firstElementChild)||void 0===_element_firstElementChild?void 0:_element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper"))},DOMAPI:shadowDOMAPI}):null),[defaultView,shadowDOMAPI]);return(0,_fluentui_react_utilities__WEBPACK_IMPORTED_MODULE_4__.E)((()=>()=>{tabster&&(0,tabster__WEBPACK_IMPORTED_MODULE_2__.hC)(tabster)}),[tabster]),tabster}},"./node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{g:()=>useTabsterAttributes});var tabster__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/tabster/dist/tabster.esm.js"),_useTabster__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js"),react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");const useTabsterAttributes=props=>{(0,_useTabster__WEBPACK_IMPORTED_MODULE_1__.p)();const strAttr=(0,tabster__WEBPACK_IMPORTED_MODULE_2__.U6)(props,!0);return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>({[tabster__WEBPACK_IMPORTED_MODULE_2__.h7]:strAttr})),[strAttr])}},"./node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function getParent(child,options={}){if(!child)return null;if(!options.skipVirtual){const virtualParent=function getVirtualParent(child){return function isVirtualElement(element){return element&&!!element._virtual}(child)&&child._virtual.parent||null}(child);if(virtualParent)return virtualParent}const parent=child.parentNode;return parent&&parent.nodeType===Node.DOCUMENT_FRAGMENT_NODE?parent.host:parent}__webpack_require__.d(__webpack_exports__,{P:()=>getParent})},"./node_modules/tabster/dist/tabster.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$d:()=>getGroupper,Az:()=>getModalizer,CP:()=>RestorerTypes,K9:()=>GroupperTabbabilities,LF:()=>GroupperMoveFocusActions,S:()=>getMover,U6:()=>getTabsterAttribute,VB:()=>MoverMoveFocusEvent,_A:()=>createTabster,gm:()=>GroupperMoveFocusEvent,h7:()=>TABSTER_ATTRIBUTE_NAME,hC:()=>disposeTabster,iA:()=>MoverDirections,mz:()=>getRestorer,uH:()=>MoverKeys});var keyborg__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/keyborg/dist/esm/index.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");const TABSTER_ATTRIBUTE_NAME="data-tabster",FOCUSABLE_SELECTOR=["a[href]","button:not([disabled])","input:not([disabled])","select:not([disabled])","textarea:not([disabled])","*[tabindex]","*[contenteditable]","details > summary","audio[controls]","video[controls]"].join(", "),AsyncFocusSources_EscapeGroupper=1,AsyncFocusSources_Restorer=2,AsyncFocusSources_Deloser=3,Visibilities_Invisible=0,Visibilities_PartiallyVisible=1,Visibilities_Visible=2,RestorerTypes={Source:0,Target:1},MoverDirections={Both:0,Vertical:1,Horizontal:2,Grid:3,GridLinear:4},MoverKeys={ArrowUp:1,ArrowDown:2,ArrowLeft:3,ArrowRight:4,PageUp:5,PageDown:6,Home:7,End:8},GroupperTabbabilities={Unlimited:0,Limited:1,LimitedTrapFocus:2},GroupperMoveFocusActions={Enter:1,Escape:2},SysDummyInputsPositions_Outside=2;function getTabsterOnElement(tabster,element){var _a;return null===(_a=tabster.storageEntry(element))||void 0===_a?void 0:_a.tabster}function updateTabsterByAttribute(tabster,element,dispose){var _a,_b;const newAttrValue=dispose||tabster._noop?void 0:element.getAttribute(TABSTER_ATTRIBUTE_NAME);let newAttr,entry=tabster.storageEntry(element);if(newAttrValue){if(newAttrValue===(null===(_a=null==entry?void 0:entry.attr)||void 0===_a?void 0:_a.string))return;try{const newValue=JSON.parse(newAttrValue);if("object"!=typeof newValue)throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);newAttr={string:newAttrValue,object:newValue}}catch(e){0}}else if(!entry)return;entry||(entry=tabster.storageEntry(element,!0)),entry.tabster||(entry.tabster={});const tabsterOnElement=entry.tabster||{},oldTabsterProps=(null===(_b=entry.attr)||void 0===_b?void 0:_b.object)||{},newTabsterProps=(null==newAttr?void 0:newAttr.object)||{};for(const key of Object.keys(oldTabsterProps))if(!newTabsterProps[key]){if("root"===key){const root=tabsterOnElement[key];root&&tabster.root.onRoot(root,!0)}switch(key){case"deloser":case"root":case"groupper":case"modalizer":case"restorer":case"mover":const part=tabsterOnElement[key];part&&(part.dispose(),delete tabsterOnElement[key]);break;case"observed":delete tabsterOnElement[key],tabster.observedElement&&tabster.observedElement.onObservedElementUpdate(element);break;case"focusable":case"outline":case"uncontrolled":case"sys":delete tabsterOnElement[key]}}for(const key of Object.keys(newTabsterProps)){const sys=newTabsterProps.sys;switch(key){case"deloser":tabsterOnElement.deloser?tabsterOnElement.deloser.setProps(newTabsterProps.deloser):tabster.deloser&&(tabsterOnElement.deloser=tabster.deloser.createDeloser(element,newTabsterProps.deloser));break;case"root":tabsterOnElement.root?tabsterOnElement.root.setProps(newTabsterProps.root):tabsterOnElement.root=tabster.root.createRoot(element,newTabsterProps.root,sys),tabster.root.onRoot(tabsterOnElement.root);break;case"modalizer":tabsterOnElement.modalizer?tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer):tabster.modalizer&&(tabsterOnElement.modalizer=tabster.modalizer.createModalizer(element,newTabsterProps.modalizer,sys));break;case"restorer":tabsterOnElement.restorer?tabsterOnElement.restorer.setProps(newTabsterProps.restorer):tabster.restorer&&newTabsterProps.restorer&&(tabsterOnElement.restorer=tabster.restorer.createRestorer(element,newTabsterProps.restorer));break;case"focusable":tabsterOnElement.focusable=newTabsterProps.focusable;break;case"groupper":tabsterOnElement.groupper?tabsterOnElement.groupper.setProps(newTabsterProps.groupper):tabster.groupper&&(tabsterOnElement.groupper=tabster.groupper.createGroupper(element,newTabsterProps.groupper,sys));break;case"mover":tabsterOnElement.mover?tabsterOnElement.mover.setProps(newTabsterProps.mover):tabster.mover&&(tabsterOnElement.mover=tabster.mover.createMover(element,newTabsterProps.mover,sys));break;case"observed":tabster.observedElement&&(tabsterOnElement.observed=newTabsterProps.observed,tabster.observedElement.onObservedElementUpdate(element));break;case"uncontrolled":tabsterOnElement.uncontrolled=newTabsterProps.uncontrolled;break;case"outline":tabster.outline&&(tabsterOnElement.outline=newTabsterProps.outline);break;case"sys":tabsterOnElement.sys=newTabsterProps.sys;break;default:console.error(`Unknown key '${key}' in data-tabster attribute value.`)}}newAttr?entry.attr=newAttr:(0===Object.keys(tabsterOnElement).length&&(delete entry.tabster,delete entry.attr),tabster.storageEntry(element,!1))}const CustomEvent_="undefined"!=typeof CustomEvent?CustomEvent:function(){};class TabsterCustomEvent extends CustomEvent_{constructor(type,detail){super(type,{bubbles:!0,cancelable:!0,composed:!0,detail}),this.details=detail}}class TabsterFocusInEvent extends TabsterCustomEvent{constructor(detail){super("tabster:focusin",detail)}}class TabsterFocusOutEvent extends TabsterCustomEvent{constructor(detail){super("tabster:focusout",detail)}}class TabsterMoveFocusEvent extends TabsterCustomEvent{constructor(detail){super("tabster:movefocus",detail)}}class MoverStateEvent extends TabsterCustomEvent{constructor(detail){super("tabster:mover:state",detail)}}class MoverMoveFocusEvent extends TabsterCustomEvent{constructor(detail){super("tabster:mover:movefocus",detail)}}class GroupperMoveFocusEvent extends TabsterCustomEvent{constructor(detail){super("tabster:groupper:movefocus",detail)}}class ModalizerActiveEvent extends TabsterCustomEvent{constructor(detail){super("tabster:modalizer:active",detail)}}class ModalizerInactiveEvent extends TabsterCustomEvent{constructor(detail){super("tabster:modalizer:inactive",detail)}}class RestorerRestoreFocusEvent extends TabsterCustomEvent{constructor(){super("tabster:restorer:restore-focus")}}class RootFocusEvent extends TabsterCustomEvent{constructor(detail){super("tabster:root:focus",detail)}}class RootBlurEvent extends TabsterCustomEvent{constructor(detail){super("tabster:root:blur",detail)}}const dom={createMutationObserver:callback=>new MutationObserver(callback),createTreeWalker:(doc,root,whatToShow,filter)=>doc.createTreeWalker(root,whatToShow,filter),getParentNode:node=>node?node.parentNode:null,getParentElement:element=>element?element.parentElement:null,nodeContains:(parent,child)=>!(!child||!(null==parent?void 0:parent.contains(child))),getActiveElement:doc=>doc.activeElement,querySelector:(element,selector)=>element.querySelector(selector),querySelectorAll:(element,selector)=>Array.prototype.slice.call(element.querySelectorAll(selector),0),getElementById:(doc,id)=>doc.getElementById(id),getFirstChild:node=>(null==node?void 0:node.firstChild)||null,getLastChild:node=>(null==node?void 0:node.lastChild)||null,getNextSibling:node=>(null==node?void 0:node.nextSibling)||null,getPreviousSibling:node=>(null==node?void 0:node.previousSibling)||null,getFirstElementChild:element=>(null==element?void 0:element.firstElementChild)||null,getLastElementChild:element=>(null==element?void 0:element.lastElementChild)||null,getNextElementSibling:element=>(null==element?void 0:element.nextElementSibling)||null,getPreviousElementSibling:element=>(null==element?void 0:element.previousElementSibling)||null,appendChild:(parent,child)=>parent.appendChild(child),insertBefore:(parent,child,referenceChild)=>parent.insertBefore(child,referenceChild),getSelection:ref=>{var _a;return(null===(_a=ref.ownerDocument)||void 0===_a?void 0:_a.getSelection())||null},getElementsByName:(referenceElement,name)=>referenceElement.ownerDocument.getElementsByName(name)};let _isBrokenIE11;const _DOMRect="undefined"!=typeof DOMRect?DOMRect:class{constructor(x,y,width,height){this.left=x||0,this.top=y||0,this.right=(x||0)+(width||0),this.bottom=(y||0)+(height||0)}};let _uidCounter=0;try{document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT),_isBrokenIE11=!1}catch(e){_isBrokenIE11=!0}function getInstanceContext(getWindow){const win=getWindow();let ctx=win.__tabsterInstanceContext;return ctx||(ctx={elementByUId:{},basics:{Promise:win.Promise||void 0,WeakRef:win.WeakRef||void 0},containerBoundingRectCache:{},lastContainerBoundingRectCacheId:0,fakeWeakRefs:[],fakeWeakRefsStarted:!1},win.__tabsterInstanceContext=ctx),ctx}class FakeWeakRef{constructor(target){this._target=target}deref(){return this._target}static cleanup(fwr,forceRemove){return!fwr._target||!(!forceRemove&&documentContains(fwr._target.ownerDocument,fwr._target))&&(delete fwr._target,!0)}}class WeakHTMLElement{constructor(getWindow,element,data){const context=getInstanceContext(getWindow);let ref;context.WeakRef?ref=new context.WeakRef(element):(ref=new FakeWeakRef(element),context.fakeWeakRefs.push(ref)),this._ref=ref,this._data=data}get(){const ref=this._ref;let element;return ref&&(element=ref.deref(),element||delete this._ref),element}getData(){return this._data}}function cleanupFakeWeakRefs(getWindow,forceRemove){const context=getInstanceContext(getWindow);context.fakeWeakRefs=context.fakeWeakRefs.filter((e=>!FakeWeakRef.cleanup(e,forceRemove)))}function startFakeWeakRefsCleanup(getWindow){const context=getInstanceContext(getWindow);context.fakeWeakRefsStarted||(context.fakeWeakRefsStarted=!0,context.WeakRef=function getWeakRef(context){return context.basics.WeakRef}(context)),context.fakeWeakRefsTimer||(context.fakeWeakRefsTimer=getWindow().setTimeout((()=>{context.fakeWeakRefsTimer=void 0,cleanupFakeWeakRefs(getWindow),startFakeWeakRefsCleanup(getWindow)}),12e4))}function createElementTreeWalker(doc,root,acceptNode){if(root.nodeType!==Node.ELEMENT_NODE)return;const filter=_isBrokenIE11?acceptNode:{acceptNode};return dom.createTreeWalker(doc,root,NodeFilter.SHOW_ELEMENT,filter,!1)}function getBoundingRect(getWindow,element){let cacheId=element.__tabsterCacheId;const context=getInstanceContext(getWindow),cached=cacheId?context.containerBoundingRectCache[cacheId]:void 0;if(cached)return cached.rect;const scrollingElement=element.ownerDocument&&element.ownerDocument.documentElement;if(!scrollingElement)return new _DOMRect;let left=0,top=0,right=scrollingElement.clientWidth,bottom=scrollingElement.clientHeight;if(element!==scrollingElement){const r=element.getBoundingClientRect();left=Math.max(left,r.left),top=Math.max(top,r.top),right=Math.min(right,r.right),bottom=Math.min(bottom,r.bottom)}const rect=new _DOMRect(left<right?left:-1,top<bottom?top:-1,left<right?right-left:0,top<bottom?bottom-top:0);return cacheId||(cacheId="r-"+ ++context.lastContainerBoundingRectCacheId,element.__tabsterCacheId=cacheId),context.containerBoundingRectCache[cacheId]={rect,element},context.containerBoundingRectCacheTimer||(context.containerBoundingRectCacheTimer=window.setTimeout((()=>{context.containerBoundingRectCacheTimer=void 0;for(const cId of Object.keys(context.containerBoundingRectCache))delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;context.containerBoundingRectCache={}}),50)),rect}function isElementVerticallyVisibleInContainer(getWindow,element,tolerance){const container=getScrollableContainer(element);if(!container)return!1;const containerRect=getBoundingRect(getWindow,container),elementRect=element.getBoundingClientRect(),intersectionTolerance=elementRect.height*(1-tolerance),totalIntersection=Math.max(0,containerRect.top-elementRect.top)+Math.max(0,elementRect.bottom-containerRect.bottom);return 0===totalIntersection||totalIntersection<=intersectionTolerance}function getScrollableContainer(element){const doc=element.ownerDocument;if(doc){for(let el=dom.getParentElement(element);el;el=dom.getParentElement(el))if(el.scrollWidth>el.clientWidth||el.scrollHeight>el.clientHeight)return el;return doc.documentElement}return null}function shouldIgnoreFocus(element){return!!element.__shouldIgnoreFocus}function getUId(wnd){const rnd=new Uint32Array(4);if(wnd.crypto&&wnd.crypto.getRandomValues)wnd.crypto.getRandomValues(rnd);else if(wnd.msCrypto&&wnd.msCrypto.getRandomValues)wnd.msCrypto.getRandomValues(rnd);else for(let i=0;i<rnd.length;i++)rnd[i]=4294967295*Math.random();const srnd=[];for(let i=0;i<rnd.length;i++)srnd.push(rnd[i].toString(36));return srnd.push("|"),srnd.push((++_uidCounter).toString(36)),srnd.push("|"),srnd.push(Date.now().toString(36)),srnd.join("")}function getElementUId(getWindow,element){const context=getInstanceContext(getWindow);let uid=element.__tabsterElementUID;return uid||(uid=element.__tabsterElementUID=getUId(getWindow())),!context.elementByUId[uid]&&documentContains(element.ownerDocument,element)&&(context.elementByUId[uid]=new WeakHTMLElement(getWindow,element)),uid}function clearElementCache(getWindow,parent){const context=getInstanceContext(getWindow);for(const key of Object.keys(context.elementByUId)){const wel=context.elementByUId[key],el=wel&&wel.get();el&&parent&&!dom.nodeContains(parent,el)||delete context.elementByUId[key]}}function documentContains(doc,element){return dom.nodeContains(null==doc?void 0:doc.body,element)}function matchesSelector(element,selector){const matches=element.matches||element.matchesSelector||element.msMatchesSelector||element.webkitMatchesSelector;return matches&&matches.call(element,selector)}function getPromise(getWindow){const context=getInstanceContext(getWindow);if(context.basics.Promise)return context.basics.Promise;throw new Error("No Promise defined.")}let _lastTabsterPartId=0;class TabsterPart{constructor(tabster,element,props){const getWindow=tabster.getWindow;this._tabster=tabster,this._element=new WeakHTMLElement(getWindow,element),this._props={...props},this.id="i"+ ++_lastTabsterPartId}getElement(){return this._element.get()}getProps(){return this._props}setProps(props){this._props={...props}}}class DummyInput{constructor(getWindow,isOutside,props,element,fixedTarget){var _a;this._focusIn=e=>{if(this._fixedTarget){const target=this._fixedTarget.get();return void(target&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(target))}const input=this.input;if(this.onFocusIn&&input){const relatedTarget=e.relatedTarget;this.onFocusIn(this,this._isBackward(!0,input,relatedTarget),relatedTarget)}},this._focusOut=e=>{if(this._fixedTarget)return;this.useDefaultAction=!1;const input=this.input;if(this.onFocusOut&&input){const relatedTarget=e.relatedTarget;this.onFocusOut(this,this._isBackward(!1,input,relatedTarget),relatedTarget)}};const win=getWindow(),input=win.document.createElement("i");input.tabIndex=0,input.setAttribute("role","none"),input.setAttribute("data-tabster-dummy",""),input.setAttribute("aria-hidden","true");const style=input.style;style.position="fixed",style.width=style.height="1px",style.opacity="0.001",style.zIndex="-1",style.setProperty("content-visibility","hidden"),function makeFocusIgnored(element){element.__shouldIgnoreFocus=!0}(input),this.input=input,this.isFirst=props.isFirst,this.isOutside=isOutside,this._isPhantom=null!==(_a=props.isPhantom)&&void 0!==_a&&_a,this._fixedTarget=fixedTarget,input.addEventListener("focusin",this._focusIn),input.addEventListener("focusout",this._focusOut),input.__tabsterDummyContainer=element,this._isPhantom&&(this._disposeTimer=win.setTimeout((()=>{delete this._disposeTimer,this.dispose()}),0),this._clearDisposeTimeout=()=>{this._disposeTimer&&(win.clearTimeout(this._disposeTimer),delete this._disposeTimer),delete this._clearDisposeTimeout})}dispose(){var _a;this._clearDisposeTimeout&&this._clearDisposeTimeout();const input=this.input;input&&(delete this._fixedTarget,delete this.onFocusIn,delete this.onFocusOut,delete this.input,input.removeEventListener("focusin",this._focusIn),input.removeEventListener("focusout",this._focusOut),delete input.__tabsterDummyContainer,null===(_a=dom.getParentNode(input))||void 0===_a||_a.removeChild(input))}setTopLeft(top,left){var _a;const style=null===(_a=this.input)||void 0===_a?void 0:_a.style;style&&(style.top=`${top}px`,style.left=`${left}px`)}_isBackward(isIn,current,previous){return isIn&&!previous?!this.isFirst:!!(previous&&current.compareDocumentPosition(previous)&Node.DOCUMENT_POSITION_FOLLOWING)}}const DummyInputManagerPriorities_Root=1,DummyInputManagerPriorities_Modalizer=2,DummyInputManagerPriorities_Mover=3,DummyInputManagerPriorities_Groupper=4;class DummyInputManager{constructor(tabster,element,priority,sys,outsideByDefault,callForDefaultAction){this._element=element,this._instance=new DummyInputManagerCore(tabster,element,this,priority,sys,outsideByDefault,callForDefaultAction)}_setHandlers(onFocusIn,onFocusOut){this._onFocusIn=onFocusIn,this._onFocusOut=onFocusOut}moveOut(backwards){var _a;null===(_a=this._instance)||void 0===_a||_a.moveOut(backwards)}moveOutWithDefaultAction(backwards,relatedEvent){var _a;null===(_a=this._instance)||void 0===_a||_a.moveOutWithDefaultAction(backwards,relatedEvent)}getHandler(isIn){return isIn?this._onFocusIn:this._onFocusOut}setTabbable(tabbable){var _a;null===(_a=this._instance)||void 0===_a||_a.setTabbable(this,tabbable)}dispose(){this._instance&&(this._instance.dispose(this),delete this._instance),delete this._onFocusIn,delete this._onFocusOut}static moveWithPhantomDummy(tabster,element,moveOutOfElement,isBackward,relatedEvent){const input=new DummyInput(tabster.getWindow,!0,{isPhantom:!0,isFirst:!0}).input;if(input){let parent,insertBefore;if("BODY"===element.tagName)parent=element,insertBefore=moveOutOfElement&&isBackward||!moveOutOfElement&&!isBackward?dom.getFirstElementChild(element):null;else{let potentialDummy,dummyFor;moveOutOfElement&&(!isBackward||isBackward&&!tabster.focusable.isFocusable(element,!1,!0,!0))?(parent=element,insertBefore=isBackward?element.firstElementChild:null):(parent=dom.getParentElement(element),insertBefore=moveOutOfElement&&isBackward||!moveOutOfElement&&!isBackward?element:dom.getNextElementSibling(element));do{potentialDummy=moveOutOfElement&&isBackward||!moveOutOfElement&&!isBackward?dom.getPreviousElementSibling(insertBefore):insertBefore,dummyFor=getDummyInputContainer(potentialDummy),dummyFor===element?insertBefore=moveOutOfElement&&isBackward||!moveOutOfElement&&!isBackward?potentialDummy:dom.getNextElementSibling(potentialDummy):dummyFor=null}while(dummyFor)}(null==parent?void 0:parent.dispatchEvent(new TabsterMoveFocusEvent({by:"root",owner:parent,next:null,relatedEvent})))&&(dom.insertBefore(parent,input,insertBefore),(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(input))}}static addPhantomDummyWithTarget(tabster,sourceElement,isBackward,targetElement){const input=new DummyInput(tabster.getWindow,!0,{isPhantom:!0,isFirst:!0},void 0,new WeakHTMLElement(tabster.getWindow,targetElement)).input;if(input){let dummyParent,insertBefore;!function hasSubFocusable(element){return!!element.querySelector(FOCUSABLE_SELECTOR)}(sourceElement)||isBackward?(dummyParent=dom.getParentElement(sourceElement),insertBefore=isBackward?sourceElement:dom.getNextElementSibling(sourceElement)):(dummyParent=sourceElement,insertBefore=dom.getFirstElementChild(sourceElement)),dummyParent&&dom.insertBefore(dummyParent,input,insertBefore)}}}class DummyInputObserver{constructor(win){this._updateQueue=new Set,this._lastUpdateQueueTime=0,this._changedParents=new WeakSet,this._dummyElements=[],this._dummyCallbacks=new WeakMap,this._domChanged=parent=>{var _a;this._changedParents.has(parent)||(this._changedParents.add(parent),this._updateDummyInputsTimer||(this._updateDummyInputsTimer=null===(_a=this._win)||void 0===_a?void 0:_a.call(this).setTimeout((()=>{delete this._updateDummyInputsTimer;for(const ref of this._dummyElements){const dummyElement=ref.get();if(dummyElement){const callback=this._dummyCallbacks.get(dummyElement);if(callback){const dummyParent=dom.getParentNode(dummyElement);dummyParent&&!this._changedParents.has(dummyParent)||callback()}}}this._changedParents=new WeakSet}),100)))},this._win=win}add(dummy,callback){!this._dummyCallbacks.has(dummy)&&this._win&&(this._dummyElements.push(new WeakHTMLElement(this._win,dummy)),this._dummyCallbacks.set(dummy,callback),this.domChanged=this._domChanged)}remove(dummy){this._dummyElements=this._dummyElements.filter((ref=>{const element=ref.get();return element&&element!==dummy})),this._dummyCallbacks.delete(dummy),0===this._dummyElements.length&&delete this.domChanged}dispose(){var _a;const win=null===(_a=this._win)||void 0===_a?void 0:_a.call(this);this._updateTimer&&(null==win||win.clearTimeout(this._updateTimer),delete this._updateTimer),this._updateDummyInputsTimer&&(null==win||win.clearTimeout(this._updateDummyInputsTimer),delete this._updateDummyInputsTimer),this._changedParents=new WeakSet,this._dummyCallbacks=new WeakMap,this._dummyElements=[],this._updateQueue.clear(),delete this.domChanged,delete this._win}updatePositions(compute){this._win&&(this._updateQueue.add(compute),this._lastUpdateQueueTime=Date.now(),this._scheduledUpdatePositions())}_scheduledUpdatePositions(){var _a;this._updateTimer||(this._updateTimer=null===(_a=this._win)||void 0===_a?void 0:_a.call(this).setTimeout((()=>{if(delete this._updateTimer,this._lastUpdateQueueTime+100<=Date.now()){const scrollTopLeftCache=new Map,setTopLeftCallbacks=[];for(const compute of this._updateQueue)setTopLeftCallbacks.push(compute(scrollTopLeftCache));this._updateQueue.clear();for(const setTopLeft of setTopLeftCallbacks)setTopLeft();scrollTopLeftCache.clear()}else this._scheduledUpdatePositions()}),100))}}class DummyInputManagerCore{constructor(tabster,element,manager,priority,sys,outsideByDefault,callForDefaultAction){this._wrappers=[],this._isOutside=!1,this._transformElements=new Set,this._onFocusIn=(dummyInput,isBackward,relatedTarget)=>{this._onFocus(!0,dummyInput,isBackward,relatedTarget)},this._onFocusOut=(dummyInput,isBackward,relatedTarget)=>{this._onFocus(!1,dummyInput,isBackward,relatedTarget)},this.moveOut=backwards=>{var _a;const first=this._firstDummy,last=this._lastDummy;if(first&&last){this._ensurePosition();const firstInput=first.input,lastInput=last.input,element=null===(_a=this._element)||void 0===_a?void 0:_a.get();if(firstInput&&lastInput&&element){let toFocus;backwards?(firstInput.tabIndex=0,toFocus=firstInput):(lastInput.tabIndex=0,toFocus=lastInput),toFocus&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(toFocus)}}},this.moveOutWithDefaultAction=(backwards,relatedEvent)=>{var _a;const first=this._firstDummy,last=this._lastDummy;if(first&&last){this._ensurePosition();const firstInput=first.input,lastInput=last.input,element=null===(_a=this._element)||void 0===_a?void 0:_a.get();if(firstInput&&lastInput&&element){let toFocus;backwards?!first.isOutside&&this._tabster.focusable.isFocusable(element,!0,!0,!0)?toFocus=element:(first.useDefaultAction=!0,firstInput.tabIndex=0,toFocus=firstInput):(last.useDefaultAction=!0,lastInput.tabIndex=0,toFocus=lastInput),toFocus&&element.dispatchEvent(new TabsterMoveFocusEvent({by:"root",owner:element,next:null,relatedEvent}))&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(toFocus)}}},this.setTabbable=(manager,tabbable)=>{var _a,_b;for(const w of this._wrappers)if(w.manager===manager){w.tabbable=tabbable;break}const wrapper=this._getCurrent();if(wrapper){const tabIndex=wrapper.tabbable?0:-1;let input=null===(_a=this._firstDummy)||void 0===_a?void 0:_a.input;input&&(input.tabIndex=tabIndex),input=null===(_b=this._lastDummy)||void 0===_b?void 0:_b.input,input&&(input.tabIndex=tabIndex)}},this._addDummyInputs=()=>{this._addTimer||(this._addTimer=this._getWindow().setTimeout((()=>{delete this._addTimer,this._ensurePosition(),this._addTransformOffsets()}),0))},this._addTransformOffsets=()=>{this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets)},this._computeTransformOffsets=scrollTopLeftCache=>{var _a,_b;const from=(null===(_a=this._firstDummy)||void 0===_a?void 0:_a.input)||(null===(_b=this._lastDummy)||void 0===_b?void 0:_b.input),transformElements=this._transformElements,newTransformElements=new Set;let scrollTop=0,scrollLeft=0;const win=this._getWindow();for(let element=from;element&&element.nodeType===Node.ELEMENT_NODE;element=dom.getParentElement(element)){let scrollTopLeft=scrollTopLeftCache.get(element);if(void 0===scrollTopLeft){const transform=win.getComputedStyle(element).transform;transform&&"none"!==transform&&(scrollTopLeft={scrollTop:element.scrollTop,scrollLeft:element.scrollLeft}),scrollTopLeftCache.set(element,scrollTopLeft||null)}scrollTopLeft&&(newTransformElements.add(element),transformElements.has(element)||element.addEventListener("scroll",this._addTransformOffsets),scrollTop+=scrollTopLeft.scrollTop,scrollLeft+=scrollTopLeft.scrollLeft)}for(const el of transformElements)newTransformElements.has(el)||el.removeEventListener("scroll",this._addTransformOffsets);return this._transformElements=newTransformElements,()=>{var _a,_b;null===(_a=this._firstDummy)||void 0===_a||_a.setTopLeft(scrollTop,scrollLeft),null===(_b=this._lastDummy)||void 0===_b||_b.setTopLeft(scrollTop,scrollLeft)}};const el=element.get();if(!el)throw new Error("No element");this._tabster=tabster,this._getWindow=tabster.getWindow,this._callForDefaultAction=callForDefaultAction;const instance=el.__tabsterDummy;if((instance||this)._wrappers.push({manager,priority,tabbable:!0}),instance)return instance;el.__tabsterDummy=this;const forcedDummyPosition=null==sys?void 0:sys.dummyInputsPosition,tagName=el.tagName;this._isOutside=forcedDummyPosition?forcedDummyPosition===SysDummyInputsPositions_Outside:(outsideByDefault||"UL"===tagName||"OL"===tagName||"TABLE"===tagName)&&!("LI"===tagName||"TD"===tagName||"TH"===tagName),this._firstDummy=new DummyInput(this._getWindow,this._isOutside,{isFirst:!0},element),this._lastDummy=new DummyInput(this._getWindow,this._isOutside,{isFirst:!1},element);const dummyElement=this._firstDummy.input;dummyElement&&tabster._dummyObserver.add(dummyElement,this._addDummyInputs),this._firstDummy.onFocusIn=this._onFocusIn,this._firstDummy.onFocusOut=this._onFocusOut,this._lastDummy.onFocusIn=this._onFocusIn,this._lastDummy.onFocusOut=this._onFocusOut,this._element=element,this._addDummyInputs()}dispose(manager,force){var _a,_b,_c,_d;if(0===(this._wrappers=this._wrappers.filter((w=>w.manager!==manager&&!force))).length){delete(null===(_a=this._element)||void 0===_a?void 0:_a.get()).__tabsterDummy;for(const el of this._transformElements)el.removeEventListener("scroll",this._addTransformOffsets);this._transformElements.clear();const win=this._getWindow();this._addTimer&&(win.clearTimeout(this._addTimer),delete this._addTimer);const dummyElement=null===(_b=this._firstDummy)||void 0===_b?void 0:_b.input;dummyElement&&this._tabster._dummyObserver.remove(dummyElement),null===(_c=this._firstDummy)||void 0===_c||_c.dispose(),null===(_d=this._lastDummy)||void 0===_d||_d.dispose()}}_onFocus(isIn,dummyInput,isBackward,relatedTarget){var _a;const wrapper=this._getCurrent();!wrapper||dummyInput.useDefaultAction&&!this._callForDefaultAction||null===(_a=wrapper.manager.getHandler(isIn))||void 0===_a||_a(dummyInput,isBackward,relatedTarget)}_getCurrent(){return this._wrappers.sort(((a,b)=>a.tabbable!==b.tabbable?a.tabbable?-1:1:a.priority-b.priority)),this._wrappers[0]}_ensurePosition(){var _a,_b,_c;const element=null===(_a=this._element)||void 0===_a?void 0:_a.get(),firstDummyInput=null===(_b=this._firstDummy)||void 0===_b?void 0:_b.input,lastDummyInput=null===(_c=this._lastDummy)||void 0===_c?void 0:_c.input;if(element&&firstDummyInput&&lastDummyInput)if(this._isOutside){const elementParent=dom.getParentNode(element);if(elementParent){const nextSibling=dom.getNextSibling(element);nextSibling!==lastDummyInput&&dom.insertBefore(elementParent,lastDummyInput,nextSibling),dom.getPreviousElementSibling(element)!==firstDummyInput&&dom.insertBefore(elementParent,firstDummyInput,element)}}else{dom.getLastElementChild(element)!==lastDummyInput&&dom.appendChild(element,lastDummyInput);const firstElementChild=dom.getFirstElementChild(element);firstElementChild&&firstElementChild!==firstDummyInput&&firstElementChild.parentNode&&dom.insertBefore(firstElementChild.parentNode,firstDummyInput,firstElementChild)}}}function getLastChild$2(container){let lastChild=null;for(let i=dom.getLastElementChild(container);i;i=dom.getLastElementChild(i))lastChild=i;return lastChild||void 0}function augmentAttribute(tabster,element,name,value){const entry=tabster.storageEntry(element,!0);let ret=!1;if(!entry.aug){if(void 0===value)return ret;entry.aug={}}if(void 0===value){if(name in entry.aug){const origVal=entry.aug[name];delete entry.aug[name],null===origVal?element.removeAttribute(name):element.setAttribute(name,origVal),ret=!0}}else{let origValue;name in entry.aug||(origValue=element.getAttribute(name)),void 0!==origValue&&origValue!==value&&(entry.aug[name]=origValue,null===value?element.removeAttribute(name):element.setAttribute(name,value),ret=!0)}return void 0===value&&0===Object.keys(entry.aug).length&&(delete entry.aug,tabster.storageEntry(element,!1)),ret}function isDisplayNone(element){var _a,_b;const elementDocument=element.ownerDocument,computedStyle=null===(_a=elementDocument.defaultView)||void 0===_a?void 0:_a.getComputedStyle(element);if(null===element.offsetParent&&elementDocument.body!==element&&"fixed"!==(null==computedStyle?void 0:computedStyle.position))return!0;if("hidden"===(null==computedStyle?void 0:computedStyle.visibility))return!0;if("fixed"===(null==computedStyle?void 0:computedStyle.position)){if("none"===computedStyle.display)return!0;if(null===(null===(_b=element.parentElement)||void 0===_b?void 0:_b.offsetParent)&&elementDocument.body!==element.parentElement)return!0}return!1}function isRadio(element){return"INPUT"===element.tagName&&!!element.name&&"radio"===element.type}function getDummyInputContainer(element){var _a;return(null===(_a=null==element?void 0:element.__tabsterDummyContainer)||void 0===_a?void 0:_a.get())||null}function getTabsterAttribute(props,plain){const attr=JSON.stringify(props);return!0===plain?attr:{[TABSTER_ATTRIBUTE_NAME]:attr}}function setTabsterAttribute(element,newProps,update){let props;if(update){const attr=element.getAttribute(TABSTER_ATTRIBUTE_NAME);if(attr)try{props=JSON.parse(attr)}catch(e){0}}props||(props={}),function mergeTabsterProps(props,newProps){for(const key of Object.keys(newProps)){const value=newProps[key];value?props[key]=value:delete props[key]}}(props,newProps),Object.keys(props).length>0?element.setAttribute(TABSTER_ATTRIBUTE_NAME,getTabsterAttribute(props,!0)):element.removeAttribute(TABSTER_ATTRIBUTE_NAME)}class RootDummyManager extends DummyInputManager{constructor(tabster,element,setFocused,sys){super(tabster,element,DummyInputManagerPriorities_Root,sys,void 0,!0),this._onDummyInputFocus=dummyInput=>{var _a;if(dummyInput.useDefaultAction)this._setFocused(!1);else{this._tabster.keyboardNavigation.setNavigatingWithKeyboard(!0);const element=this._element.get();if(element){this._setFocused(!0);const toFocus=this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst,{container:element,ignoreAccessibility:!0});if(toFocus)return void(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(toFocus)}null===(_a=dummyInput.input)||void 0===_a||_a.blur()}},this._setHandlers(this._onDummyInputFocus),this._tabster=tabster,this._setFocused=setFocused}}class Root extends TabsterPart{constructor(tabster,element,onDispose,props,sys){super(tabster,element,props),this._isFocused=!1,this._setFocused=hasFocused=>{var _a;if(this._setFocusedTimer&&(this._tabster.getWindow().clearTimeout(this._setFocusedTimer),delete this._setFocusedTimer),this._isFocused===hasFocused)return;const element=this._element.get();element&&(hasFocused?(this._isFocused=!0,null===(_a=this._dummyManager)||void 0===_a||_a.setTabbable(!1),element.dispatchEvent(new RootFocusEvent({element}))):this._setFocusedTimer=this._tabster.getWindow().setTimeout((()=>{var _a;delete this._setFocusedTimer,this._isFocused=!1,null===(_a=this._dummyManager)||void 0===_a||_a.setTabbable(!0),element.dispatchEvent(new RootBlurEvent({element}))}),0))},this._onFocusIn=event=>{const getParent=this._tabster.getParent,rootElement=this._element.get();let curElement=event.composedPath()[0];do{if(curElement===rootElement)return void this._setFocused(!0);curElement=curElement&&getParent(curElement)}while(curElement)},this._onFocusOut=()=>{this._setFocused(!1)},this._onDispose=onDispose;const win=tabster.getWindow;this.uid=getElementUId(win,element),this._sys=sys,(tabster.controlTab||tabster.rootDummyInputs)&&this.addDummyInputs();const doc=win().document;doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.Oy,this._onFocusIn),doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.RY,this._onFocusOut),this._add()}addDummyInputs(){this._dummyManager||(this._dummyManager=new RootDummyManager(this._tabster,this._element,this._setFocused,this._sys))}dispose(){var _a;this._onDispose(this);const win=this._tabster.getWindow(),doc=win.document;doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.Oy,this._onFocusIn),doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.RY,this._onFocusOut),this._setFocusedTimer&&(win.clearTimeout(this._setFocusedTimer),delete this._setFocusedTimer),null===(_a=this._dummyManager)||void 0===_a||_a.dispose(),this._remove()}moveOutWithDefaultAction(isBackward,relatedEvent){const dummyManager=this._dummyManager;if(dummyManager)dummyManager.moveOutWithDefaultAction(isBackward,relatedEvent);else{const el=this.getElement();el&&RootDummyManager.moveWithPhantomDummy(this._tabster,el,!0,isBackward,relatedEvent)}}_add(){0}_remove(){0}}class RootAPI{constructor(tabster,autoRoot){this._autoRootWaiting=!1,this._roots={},this._forceDummy=!1,this.rootById={},this._autoRootCreate=()=>{var _a;const doc=this._win().document,body=doc.body;if(body){this._autoRootUnwait(doc);const props=this._autoRoot;if(props)return setTabsterAttribute(body,{root:props},!0),updateTabsterByAttribute(this._tabster,body),null===(_a=getTabsterOnElement(this._tabster,body))||void 0===_a?void 0:_a.root}else this._autoRootWaiting||(this._autoRootWaiting=!0,doc.addEventListener("readystatechange",this._autoRootCreate))},this._onRootDispose=root=>{delete this._roots[root.id]},this._tabster=tabster,this._win=tabster.getWindow,this._autoRoot=autoRoot,tabster.queueInit((()=>{this._autoRoot&&this._autoRootCreate()}))}_autoRootUnwait(doc){doc.removeEventListener("readystatechange",this._autoRootCreate),this._autoRootWaiting=!1}dispose(){const win=this._win();this._autoRootUnwait(win.document),delete this._autoRoot,Object.keys(this._roots).forEach((rootId=>{this._roots[rootId]&&(this._roots[rootId].dispose(),delete this._roots[rootId])})),this.rootById={}}createRoot(element,props,sys){const newRoot=new Root(this._tabster,element,this._onRootDispose,props,sys);return this._roots[newRoot.id]=newRoot,this._forceDummy&&newRoot.addDummyInputs(),newRoot}addDummyInputs(){this._forceDummy=!0;const roots=this._roots;for(const id of Object.keys(roots))roots[id].addDummyInputs()}static getRootByUId(getWindow,id){const tabster=getWindow().__tabsterInstance;return tabster&&tabster.root.rootById[id]}static getTabsterContext(tabster,element,options){var _a,_b,_c,_d;if(void 0===options&&(options={}),!element.ownerDocument)return;const{checkRtl,referenceElement}=options,getParent=tabster.getParent;let root,modalizer,groupper,mover;tabster.drainInitQueue();let groupperBeforeMover,modalizerInGroupper,dirRightToLeft,uncontrolled,excludedFromMover=!1,curElement=referenceElement||element;const ignoreKeydown={};for(;curElement&&(!root||checkRtl);){const tabsterOnElement=getTabsterOnElement(tabster,curElement);if(checkRtl&&void 0===dirRightToLeft){const dir=curElement.dir;dir&&(dirRightToLeft="rtl"===dir.toLowerCase())}if(!tabsterOnElement){curElement=getParent(curElement);continue}const tagName=curElement.tagName;(tabsterOnElement.uncontrolled||"IFRAME"===tagName||"WEBVIEW"===tagName)&&(uncontrolled=curElement),mover||!(null===(_a=tabsterOnElement.focusable)||void 0===_a?void 0:_a.excludeFromMover)||groupper||(excludedFromMover=!0);const curModalizer=tabsterOnElement.modalizer,curGroupper=tabsterOnElement.groupper,curMover=tabsterOnElement.mover;!modalizer&&curModalizer&&(modalizer=curModalizer),groupper||!curGroupper||modalizer&&!curModalizer||(modalizer?(!curGroupper.isActive()&&curGroupper.getProps().tabbability&&modalizer.userId!==(null===(_b=tabster.modalizer)||void 0===_b?void 0:_b.activeId)&&(modalizer=void 0,groupper=curGroupper),modalizerInGroupper=curGroupper):groupper=curGroupper),mover||!curMover||modalizer&&!curModalizer||curGroupper&&curElement===element||!curElement.contains(element)||(mover=curMover,groupperBeforeMover=!!groupper&&groupper!==curGroupper),tabsterOnElement.root&&(root=tabsterOnElement.root),(null===(_c=tabsterOnElement.focusable)||void 0===_c?void 0:_c.ignoreKeydown)&&Object.assign(ignoreKeydown,tabsterOnElement.focusable.ignoreKeydown),curElement=getParent(curElement)}if(!root){const rootAPI=tabster.root;rootAPI._autoRoot&&(null===(_d=element.ownerDocument)||void 0===_d?void 0:_d.body)&&(root=rootAPI._autoRootCreate())}groupper&&!mover&&(groupperBeforeMover=!0);return root?{root,modalizer,groupper,mover,groupperBeforeMover,modalizerInGroupper,rtl:checkRtl?!!dirRightToLeft:void 0,uncontrolled,excludedFromMover,ignoreKeydown:event=>!!ignoreKeydown[event.key]}:void 0}static getRoot(tabster,element){var _a;const getParent=tabster.getParent;for(let el=element;el;el=getParent(el)){const root=null===(_a=getTabsterOnElement(tabster,el))||void 0===_a?void 0:_a.root;if(root)return root}}onRoot(root,removed){removed?delete this.rootById[root.uid]:this.rootById[root.uid]=root}}class Subscribable{constructor(){this._callbacks=[]}dispose(){this._callbacks=[],delete this._val}subscribe(callback){const callbacks=this._callbacks;callbacks.indexOf(callback)<0&&callbacks.push(callback)}subscribeFirst(callback){const callbacks=this._callbacks,index=callbacks.indexOf(callback);index>=0&&callbacks.splice(index,1),callbacks.unshift(callback)}unsubscribe(callback){const index=this._callbacks.indexOf(callback);index>=0&&this._callbacks.splice(index,1)}setVal(val,detail){this._val!==val&&(this._val=val,this._callCallbacks(val,detail))}getVal(){return this._val}trigger(val,detail){this._callCallbacks(val,detail)}_callCallbacks(val,detail){this._callbacks.forEach((callback=>callback(val,detail)))}}class FocusableAPI{constructor(tabster){this._tabster=tabster}dispose(){}getProps(element){const tabsterOnElement=getTabsterOnElement(this._tabster,element);return tabsterOnElement&&tabsterOnElement.focusable||{}}isFocusable(el,includeProgrammaticallyFocusable,noVisibleCheck,noAccessibleCheck){return!(!matchesSelector(el,FOCUSABLE_SELECTOR)||!includeProgrammaticallyFocusable&&-1===el.tabIndex)&&((noVisibleCheck||this.isVisible(el))&&(noAccessibleCheck||this.isAccessible(el)))}isVisible(el){if(!el.ownerDocument||el.nodeType!==Node.ELEMENT_NODE)return!1;if(isDisplayNone(el))return!1;const rect=el.ownerDocument.body.getBoundingClientRect();return 0!==rect.width||0!==rect.height}isAccessible(el){var _a;for(let e=el;e;e=dom.getParentElement(e)){const tabsterOnElement=getTabsterOnElement(this._tabster,e);if(this._isHidden(e))return!1;if(!(null===(_a=null==tabsterOnElement?void 0:tabsterOnElement.focusable)||void 0===_a?void 0:_a.ignoreAriaDisabled)&&this._isDisabled(e))return!1}return!0}_isDisabled(el){return el.hasAttribute("disabled")}_isHidden(el){var _a;const attrVal=el.getAttribute("aria-hidden");return!(!attrVal||"true"!==attrVal.toLowerCase()||(null===(_a=this._tabster.modalizer)||void 0===_a?void 0:_a.isAugmented(el)))}findFirst(options,out){return this.findElement({...options},out)}findLast(options,out){return this.findElement({isBackward:!0,...options},out)}findNext(options,out){return this.findElement({...options},out)}findPrev(options,out){return this.findElement({...options,isBackward:!0},out)}findDefault(options,out){return this.findElement({...options,acceptCondition:el=>this.isFocusable(el,options.includeProgrammaticallyFocusable)&&!!this.getProps(el).isDefault},out)||null}findAll(options){return this._findElements(!0,options)||[]}findElement(options,out){const found=this._findElements(!1,options,out);return found?found[0]:found}_findElements(isFindAll,options,out){var _a,_b,_c;const{container,currentElement=null,includeProgrammaticallyFocusable,useActiveModalizer,ignoreAccessibility,modalizerId,isBackward,onElement}=options;out||(out={});const elements=[];let{acceptCondition}=options;const hasCustomCondition=!!acceptCondition;if(!container)return null;acceptCondition||(acceptCondition=el=>this.isFocusable(el,includeProgrammaticallyFocusable,!1,ignoreAccessibility));const acceptElementState={container,modalizerUserId:void 0===modalizerId&&useActiveModalizer?null===(_a=this._tabster.modalizer)||void 0===_a?void 0:_a.activeId:modalizerId||(null===(_c=null===(_b=RootAPI.getTabsterContext(this._tabster,container))||void 0===_b?void 0:_b.modalizer)||void 0===_c?void 0:_c.userId),from:currentElement||container,isBackward,isFindAll,acceptCondition,hasCustomCondition,includeProgrammaticallyFocusable,ignoreAccessibility,cachedGrouppers:{},cachedRadioGroups:{}},walker=createElementTreeWalker(container.ownerDocument,container,(node=>this._acceptElement(node,acceptElementState)));if(!walker)return null;const prepareForNextElement=shouldContinueIfNotFound=>{var _a,_b;const foundElement=null!==(_a=acceptElementState.foundElement)&&void 0!==_a?_a:acceptElementState.foundBackward;return foundElement&&elements.push(foundElement),isFindAll?!(foundElement&&(acceptElementState.found=!1,delete acceptElementState.foundElement,delete acceptElementState.foundBackward,delete acceptElementState.fromCtx,acceptElementState.from=foundElement,onElement&&!onElement(foundElement)))&&!(!foundElement&&!shouldContinueIfNotFound):(foundElement&&out&&(out.uncontrolled=null===(_b=RootAPI.getTabsterContext(this._tabster,foundElement))||void 0===_b?void 0:_b.uncontrolled),!(!shouldContinueIfNotFound||foundElement))};if(currentElement||(out.outOfDOMOrder=!0),currentElement&&dom.nodeContains(container,currentElement))walker.currentNode=currentElement;else if(isBackward){const lastChild=getLastChild$2(container);if(!lastChild)return null;if(this._acceptElement(lastChild,acceptElementState)===NodeFilter.FILTER_ACCEPT&&!prepareForNextElement(!0))return acceptElementState.skippedFocusable&&(out.outOfDOMOrder=!0),elements;walker.currentNode=lastChild}do{isBackward?walker.previousNode():walker.nextNode()}while(prepareForNextElement());return acceptElementState.skippedFocusable&&(out.outOfDOMOrder=!0),elements.length?elements:null}_acceptElement(element,state){var _a,_b,_c;if(state.found)return NodeFilter.FILTER_ACCEPT;const foundBackward=state.foundBackward;if(foundBackward&&(element===foundBackward||!dom.nodeContains(foundBackward,element)))return state.found=!0,state.foundElement=foundBackward,NodeFilter.FILTER_ACCEPT;const container=state.container;if(element===container)return NodeFilter.FILTER_SKIP;if(!dom.nodeContains(container,element))return NodeFilter.FILTER_REJECT;if(getDummyInputContainer(element))return NodeFilter.FILTER_REJECT;if(dom.nodeContains(state.rejectElementsFrom,element))return NodeFilter.FILTER_REJECT;const ctx=state.currentCtx=RootAPI.getTabsterContext(this._tabster,element);if(!ctx)return NodeFilter.FILTER_SKIP;if(shouldIgnoreFocus(element))return this.isFocusable(element,void 0,!0,!0)&&(state.skippedFocusable=!0),NodeFilter.FILTER_SKIP;if(!state.hasCustomCondition&&("IFRAME"===element.tagName||"WEBVIEW"===element.tagName))return(null===(_a=ctx.modalizer)||void 0===_a?void 0:_a.userId)===(null===(_b=this._tabster.modalizer)||void 0===_b?void 0:_b.activeId)?(state.found=!0,state.rejectElementsFrom=state.foundElement=element,NodeFilter.FILTER_ACCEPT):NodeFilter.FILTER_REJECT;if(!state.ignoreAccessibility&&!this.isAccessible(element))return this.isFocusable(element,!1,!0,!0)&&(state.skippedFocusable=!0),NodeFilter.FILTER_REJECT;let result,fromCtx=state.fromCtx;fromCtx||(fromCtx=state.fromCtx=RootAPI.getTabsterContext(this._tabster,state.from));const fromMover=null==fromCtx?void 0:fromCtx.mover;let groupper=ctx.groupper,mover=ctx.mover;if(result=null===(_c=this._tabster.modalizer)||void 0===_c?void 0:_c.acceptElement(element,state),void 0!==result&&(state.skippedFocusable=!0),void 0===result&&(groupper||mover||fromMover)){const groupperElement=null==groupper?void 0:groupper.getElement(),fromMoverElement=null==fromMover?void 0:fromMover.getElement();let moverElement=null==mover?void 0:mover.getElement();moverElement&&dom.nodeContains(fromMoverElement,moverElement)&&dom.nodeContains(container,fromMoverElement)&&(!groupperElement||!mover||dom.nodeContains(fromMoverElement,groupperElement))&&(mover=fromMover,moverElement=fromMoverElement),!groupperElement||groupperElement!==container&&dom.nodeContains(container,groupperElement)||(groupper=void 0),moverElement&&!dom.nodeContains(container,moverElement)&&(mover=void 0),groupper&&mover&&(moverElement&&groupperElement&&!dom.nodeContains(groupperElement,moverElement)?mover=void 0:groupper=void 0),groupper&&(result=groupper.acceptElement(element,state)),mover&&(result=mover.acceptElement(element,state))}if(void 0===result&&(result=state.acceptCondition(element)?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP,result===NodeFilter.FILTER_SKIP&&this.isFocusable(element,!1,!0,!0)&&(state.skippedFocusable=!0)),result===NodeFilter.FILTER_ACCEPT&&!state.found){if(!state.isFindAll&&isRadio(element)&&!element.checked){const radioGroupName=element.name;let radioGroup=state.cachedRadioGroups[radioGroupName];if(radioGroup||(radioGroup=function getRadioButtonGroup(element){if(!isRadio(element))return;const name=element.name;let checked,radioButtons=Array.from(dom.getElementsByName(element,name));return radioButtons=radioButtons.filter((el=>!!isRadio(el)&&(el.checked&&(checked=el),!0))),{name,buttons:new Set(radioButtons),checked}}(element),radioGroup&&(state.cachedRadioGroups[radioGroupName]=radioGroup)),(null==radioGroup?void 0:radioGroup.checked)&&radioGroup.checked!==element)return NodeFilter.FILTER_SKIP}state.isBackward?(state.foundBackward=element,result=NodeFilter.FILTER_SKIP):(state.found=!0,state.foundElement=element)}return result}}const Keys_Tab="Tab",Keys_Enter="Enter",Keys_Escape="Escape",Keys_PageUp="PageUp",Keys_PageDown="PageDown",Keys_End="End",Keys_Home="Home",Keys_ArrowLeft="ArrowLeft",Keys_ArrowUp="ArrowUp",Keys_ArrowRight="ArrowRight",Keys_ArrowDown="ArrowDown";const AsyncFocusIntentPriorityBySource={[AsyncFocusSources_Restorer]:0,[AsyncFocusSources_Deloser]:1,[AsyncFocusSources_EscapeGroupper]:2};class FocusedElementState extends Subscribable{constructor(tabster,getWindow){super(),this._init=()=>{const win=this._win(),doc=win.document;doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.Oy,this._onFocusIn,!0),doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.RY,this._onFocusOut,!0),win.addEventListener("keydown",this._onKeyDown,!0);const activeElement=dom.getActiveElement(doc);activeElement&&activeElement!==doc.body&&this._setFocusedElement(activeElement),this.subscribe(this._onChanged)},this._onFocusIn=e=>{const target=e.composedPath()[0];target&&this._setFocusedElement(target,e.detail.relatedTarget,e.detail.isFocusedProgrammatically)},this._onFocusOut=e=>{var _a;this._setFocusedElement(void 0,null===(_a=e.detail)||void 0===_a?void 0:_a.originalEvent.relatedTarget)},this._validateFocusedElement=element=>{},this._onKeyDown=event=>{if(event.key!==Keys_Tab||event.ctrlKey)return;const currentElement=this.getVal();if(!currentElement||!currentElement.ownerDocument||"true"===currentElement.contentEditable)return;const tabster=this._tabster,controlTab=tabster.controlTab,ctx=RootAPI.getTabsterContext(tabster,currentElement);if(!ctx||ctx.ignoreKeydown(event))return;const isBackward=event.shiftKey,next=FocusedElementState.findNextTabbable(tabster,ctx,void 0,currentElement,void 0,isBackward,!0),rootElement=ctx.root.getElement();if(!rootElement)return;const nextElement=null==next?void 0:next.element,uncontrolledCompletelyContainer=function getUncontrolledCompletelyContainer(tabster,element){var _a;const getParent=tabster.getParent;let el=element;do{const uncontrolledOnElement=null===(_a=getTabsterOnElement(tabster,el))||void 0===_a?void 0:_a.uncontrolled;if(uncontrolledOnElement&&tabster.uncontrolled.isUncontrolledCompletely(el,!!uncontrolledOnElement.completely))return el;el=getParent(el)}while(el)}(tabster,currentElement);if(nextElement){const nextUncontrolled=next.uncontrolled;if(ctx.uncontrolled||dom.nodeContains(nextUncontrolled,currentElement)){if(!next.outOfDOMOrder&&nextUncontrolled===ctx.uncontrolled||uncontrolledCompletelyContainer&&!dom.nodeContains(uncontrolledCompletelyContainer,nextElement))return;return void DummyInputManager.addPhantomDummyWithTarget(tabster,currentElement,isBackward,nextElement)}if(nextUncontrolled||"IFRAME"===nextElement.tagName)return void(rootElement.dispatchEvent(new TabsterMoveFocusEvent({by:"root",owner:rootElement,next:nextElement,relatedEvent:event}))&&DummyInputManager.moveWithPhantomDummy(this._tabster,null!=nextUncontrolled?nextUncontrolled:nextElement,!1,isBackward,event));(controlTab||(null==next?void 0:next.outOfDOMOrder))&&rootElement.dispatchEvent(new TabsterMoveFocusEvent({by:"root",owner:rootElement,next:nextElement,relatedEvent:event}))&&(event.preventDefault(),event.stopImmediatePropagation(),(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(nextElement))}else!uncontrolledCompletelyContainer&&rootElement.dispatchEvent(new TabsterMoveFocusEvent({by:"root",owner:rootElement,next:null,relatedEvent:event}))&&ctx.root.moveOutWithDefaultAction(isBackward,event)},this._onChanged=(element,detail)=>{var _a,_b;if(element)element.dispatchEvent(new TabsterFocusInEvent(detail));else{const last=null===(_a=this._lastVal)||void 0===_a?void 0:_a.get();if(last){const d={...detail},lastCtx=RootAPI.getTabsterContext(this._tabster,last),modalizerId=null===(_b=null==lastCtx?void 0:lastCtx.modalizer)||void 0===_b?void 0:_b.userId;modalizerId&&(d.modalizerId=modalizerId),last.dispatchEvent(new TabsterFocusOutEvent(d))}}},this._tabster=tabster,this._win=getWindow,tabster.queueInit(this._init)}dispose(){super.dispose();const win=this._win(),doc=win.document;doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.Oy,this._onFocusIn,!0),doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.RY,this._onFocusOut,!0),win.removeEventListener("keydown",this._onKeyDown,!0),this.unsubscribe(this._onChanged);const asyncFocus=this._asyncFocus;asyncFocus&&(win.clearTimeout(asyncFocus.timeout),delete this._asyncFocus),delete FocusedElementState._lastResetElement,delete this._nextVal,delete this._lastVal}static forgetMemorized(instance,parent){var _a,_b;let wel=FocusedElementState._lastResetElement,el=wel&&wel.get();el&&dom.nodeContains(parent,el)&&delete FocusedElementState._lastResetElement,el=null===(_b=null===(_a=instance._nextVal)||void 0===_a?void 0:_a.element)||void 0===_b?void 0:_b.get(),el&&dom.nodeContains(parent,el)&&delete instance._nextVal,wel=instance._lastVal,el=wel&&wel.get(),el&&dom.nodeContains(parent,el)&&delete instance._lastVal}getFocusedElement(){return this.getVal()}getLastFocusedElement(){var _a;let el=null===(_a=this._lastVal)||void 0===_a?void 0:_a.get();return(!el||el&&!documentContains(el.ownerDocument,el))&&(this._lastVal=el=void 0),el}focus(element,noFocusedProgrammaticallyFlag,noAccessibleCheck,preventScroll){return!!this._tabster.focusable.isFocusable(element,noFocusedProgrammaticallyFlag,!1,noAccessibleCheck)&&(element.focus({preventScroll}),!0)}focusDefault(container){const el=this._tabster.focusable.findDefault({container});return!!el&&(this._tabster.focusedElement.focus(el),!0)}getFirstOrLastTabbable(isFirst,props){var _a;const{container,ignoreAccessibility}=props;let toFocus;if(container){const ctx=RootAPI.getTabsterContext(this._tabster,container);ctx&&(toFocus=null===(_a=FocusedElementState.findNextTabbable(this._tabster,ctx,container,void 0,void 0,!isFirst,ignoreAccessibility))||void 0===_a?void 0:_a.element)}return toFocus&&!dom.nodeContains(container,toFocus)&&(toFocus=void 0),toFocus||void 0}_focusFirstOrLast(isFirst,props){const toFocus=this.getFirstOrLastTabbable(isFirst,props);return!!toFocus&&(this.focus(toFocus,!1,!0),!0)}focusFirst(props){return this._focusFirstOrLast(!0,props)}focusLast(props){return this._focusFirstOrLast(!1,props)}resetFocus(container){if(!this._tabster.focusable.isVisible(container))return!1;if(this._tabster.focusable.isFocusable(container,!0,!0,!0))this.focus(container);else{const prevTabIndex=container.getAttribute("tabindex"),prevAriaHidden=container.getAttribute("aria-hidden");container.tabIndex=-1,container.setAttribute("aria-hidden","true"),FocusedElementState._lastResetElement=new WeakHTMLElement(this._win,container),this.focus(container,!0,!0),this._setOrRemoveAttribute(container,"tabindex",prevTabIndex),this._setOrRemoveAttribute(container,"aria-hidden",prevAriaHidden)}return!0}requestAsyncFocus(source,callback,delay){const win=this._tabster.getWindow(),currentAsyncFocus=this._asyncFocus;if(currentAsyncFocus){if(AsyncFocusIntentPriorityBySource[source]>AsyncFocusIntentPriorityBySource[currentAsyncFocus.source])return;win.clearTimeout(currentAsyncFocus.timeout)}this._asyncFocus={source,callback,timeout:win.setTimeout((()=>{this._asyncFocus=void 0,callback()}),delay)}}cancelAsyncFocus(source){const asyncFocus=this._asyncFocus;(null==asyncFocus?void 0:asyncFocus.source)===source&&(this._tabster.getWindow().clearTimeout(asyncFocus.timeout),this._asyncFocus=void 0)}_setOrRemoveAttribute(element,name,value){null===value?element.removeAttribute(name):element.setAttribute(name,value)}_setFocusedElement(element,relatedTarget,isFocusedProgrammatically){var _a,_b;if(this._tabster._noop)return;const detail={relatedTarget};if(element){const lastResetElement=null===(_a=FocusedElementState._lastResetElement)||void 0===_a?void 0:_a.get();if(FocusedElementState._lastResetElement=void 0,lastResetElement===element||shouldIgnoreFocus(element))return;detail.isFocusedProgrammatically=isFocusedProgrammatically;const ctx=RootAPI.getTabsterContext(this._tabster,element),modalizerId=null===(_b=null==ctx?void 0:ctx.modalizer)||void 0===_b?void 0:_b.userId;modalizerId&&(detail.modalizerId=modalizerId)}const nextVal=this._nextVal={element:element?new WeakHTMLElement(this._win,element):void 0,detail};element&&element!==this._val&&this._validateFocusedElement(element),this._nextVal===nextVal&&this.setVal(element,detail),this._nextVal=void 0}setVal(val,detail){super.setVal(val,detail),val&&(this._lastVal=new WeakHTMLElement(this._win,val))}static findNextTabbable(tabster,ctx,container,currentElement,referenceElement,isBackward,ignoreAccessibility){const actualContainer=container||ctx.root.getElement();if(!actualContainer)return null;let next=null;const isTabbingTimer=FocusedElementState._isTabbingTimer,win=tabster.getWindow();isTabbingTimer&&win.clearTimeout(isTabbingTimer),FocusedElementState.isTabbing=!0,FocusedElementState._isTabbingTimer=win.setTimeout((()=>{delete FocusedElementState._isTabbingTimer,FocusedElementState.isTabbing=!1}),0);const modalizer=ctx.modalizer,groupper=ctx.groupper,mover=ctx.mover,callFindNext=what=>{if(next=what.findNextTabbable(currentElement,referenceElement,isBackward,ignoreAccessibility),currentElement&&!(null==next?void 0:next.element)){const parentElement=what!==modalizer&&dom.getParentElement(what.getElement());if(parentElement){const parentCtx=RootAPI.getTabsterContext(tabster,currentElement,{referenceElement:parentElement});if(parentCtx){const currentScopeElement=what.getElement(),newCurrent=isBackward?currentScopeElement:currentScopeElement&&getLastChild$2(currentScopeElement)||currentScopeElement;newCurrent&&(next=FocusedElementState.findNextTabbable(tabster,parentCtx,container,newCurrent,parentElement,isBackward,ignoreAccessibility),next&&(next.outOfDOMOrder=!0))}}}};if(groupper&&mover)callFindNext(ctx.groupperBeforeMover?groupper:mover);else if(groupper)callFindNext(groupper);else if(mover)callFindNext(mover);else if(modalizer)callFindNext(modalizer);else{const findProps={container:actualContainer,currentElement,referenceElement,ignoreAccessibility,useActiveModalizer:!0},findPropsOut={},nextElement=tabster.focusable[isBackward?"findPrev":"findNext"](findProps,findPropsOut);next={element:nextElement,outOfDOMOrder:findPropsOut.outOfDOMOrder,uncontrolled:findPropsOut.uncontrolled}}return next}}FocusedElementState.isTabbing=!1;class GroupperDummyManager extends DummyInputManager{constructor(element,groupper,tabster,sys){super(tabster,element,DummyInputManagerPriorities_Groupper,sys,!0),this._setHandlers(((dummyInput,isBackward,relatedTarget)=>{var _a,_b;const container=element.get(),input=dummyInput.input;if(container&&input){const ctx=RootAPI.getTabsterContext(tabster,input);if(ctx){let next;next=null===(_a=groupper.findNextTabbable(relatedTarget||void 0,void 0,isBackward,!0))||void 0===_a?void 0:_a.element,next||(next=null===(_b=FocusedElementState.findNextTabbable(tabster,ctx,void 0,dummyInput.isOutside?input:function getAdjacentElement(from,prev){let cur=from,adjacent=null;for(;cur&&!adjacent;)adjacent=prev?dom.getPreviousElementSibling(cur):dom.getNextElementSibling(cur),cur=dom.getParentElement(cur);return adjacent||void 0}(container,!isBackward),void 0,isBackward,!0))||void 0===_b?void 0:_b.element),next&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(next)}}}))}}class Groupper extends TabsterPart{constructor(tabster,element,onDispose,props,sys){super(tabster,element,props),this._shouldTabInside=!1,this.makeTabbable(!1),this._onDispose=onDispose,tabster.controlTab||(this.dummyManager=new GroupperDummyManager(this._element,this,tabster,sys))}dispose(){var _a;this._onDispose(this);this._element.get();null===(_a=this.dummyManager)||void 0===_a||_a.dispose(),delete this.dummyManager,delete this._first}findNextTabbable(currentElement,referenceElement,isBackward,ignoreAccessibility){const groupperElement=this.getElement();if(!groupperElement)return null;const currentIsDummy=getDummyInputContainer(currentElement)===groupperElement;if(!this._shouldTabInside&&currentElement&&dom.nodeContains(groupperElement,currentElement)&&!currentIsDummy)return{element:void 0,outOfDOMOrder:!0};const groupperFirstFocusable=this.getFirst(!0);if(!currentElement||!dom.nodeContains(groupperElement,currentElement)||currentIsDummy)return{element:groupperFirstFocusable,outOfDOMOrder:!0};const tabster=this._tabster;let uncontrolled,next=null,outOfDOMOrder=!1;if(this._shouldTabInside&&groupperFirstFocusable){const findProps={container:groupperElement,currentElement,referenceElement,ignoreAccessibility,useActiveModalizer:!0},findPropsOut={};next=tabster.focusable[isBackward?"findPrev":"findNext"](findProps,findPropsOut),outOfDOMOrder=!!findPropsOut.outOfDOMOrder,next||this._props.tabbability!==GroupperTabbabilities.LimitedTrapFocus||(next=tabster.focusable[isBackward?"findLast":"findFirst"]({container:groupperElement,ignoreAccessibility,useActiveModalizer:!0},findPropsOut),outOfDOMOrder=!0),uncontrolled=findPropsOut.uncontrolled}return{element:next,uncontrolled,outOfDOMOrder}}makeTabbable(isTabbable){this._shouldTabInside=isTabbable||!this._props.tabbability}isActive(noIfFirstIsFocused){var _a;const element=this.getElement()||null;let isParentActive=!0;for(let e=dom.getParentElement(element);e;e=dom.getParentElement(e)){const g=null===(_a=getTabsterOnElement(this._tabster,e))||void 0===_a?void 0:_a.groupper;g&&(g._shouldTabInside||(isParentActive=!1))}let ret=isParentActive?!!this._props.tabbability&&this._shouldTabInside:void 0;if(ret&&noIfFirstIsFocused){const focused=this._tabster.focusedElement.getFocusedElement();focused&&(ret=focused!==this.getFirst(!0))}return ret}getFirst(orContainer){var _a;const groupperElement=this.getElement();let first;if(groupperElement){if(orContainer&&this._tabster.focusable.isFocusable(groupperElement))return groupperElement;first=null===(_a=this._first)||void 0===_a?void 0:_a.get(),first||(first=this._tabster.focusable.findFirst({container:groupperElement,useActiveModalizer:!0})||void 0,first&&this.setFirst(first))}return first}setFirst(element){element?this._first=new WeakHTMLElement(this._tabster.getWindow,element):delete this._first}acceptElement(element,state){const cachedGrouppers=state.cachedGrouppers,parentElement=dom.getParentElement(this.getElement()),parentCtx=parentElement&&RootAPI.getTabsterContext(this._tabster,parentElement),parentCtxGroupper=null==parentCtx?void 0:parentCtx.groupper,parentGroupper=(null==parentCtx?void 0:parentCtx.groupperBeforeMover)?parentCtxGroupper:void 0;let parentGroupperElement;const getIsActive=groupper=>{let isActive,cached=cachedGrouppers[groupper.id];return cached?isActive=cached.isActive:(isActive=this.isActive(!0),cached=cachedGrouppers[groupper.id]={isActive}),isActive};if(parentGroupper&&(parentGroupperElement=parentGroupper.getElement(),!getIsActive(parentGroupper)&&parentGroupperElement&&state.container!==parentGroupperElement&&dom.nodeContains(state.container,parentGroupperElement)))return state.skippedFocusable=!0,NodeFilter.FILTER_REJECT;const isActive=getIsActive(this),groupperElement=this.getElement();if(groupperElement&&!0!==isActive){if(groupperElement===element&&parentCtxGroupper&&(parentGroupperElement||(parentGroupperElement=parentCtxGroupper.getElement()),parentGroupperElement&&!getIsActive(parentCtxGroupper)&&dom.nodeContains(state.container,parentGroupperElement)&&parentGroupperElement!==state.container))return state.skippedFocusable=!0,NodeFilter.FILTER_REJECT;if(groupperElement!==element&&dom.nodeContains(groupperElement,element))return state.skippedFocusable=!0,NodeFilter.FILTER_REJECT;const cached=cachedGrouppers[this.id];let first;if(first="first"in cached?cached.first:cached.first=this.getFirst(!0),first&&state.acceptCondition(first))return state.rejectElementsFrom=groupperElement,state.skippedFocusable=!0,first!==state.from?(state.found=!0,state.foundElement=first,NodeFilter.FILTER_ACCEPT):NodeFilter.FILTER_REJECT}}}class GroupperAPI{constructor(tabster,getWindow){this._current={},this._grouppers={},this._init=()=>{const win=this._win();this._tabster.focusedElement.subscribeFirst(this._onFocus);const doc=win.document,activeElement=dom.getActiveElement(doc);activeElement&&this._onFocus(activeElement),doc.addEventListener("mousedown",this._onMouseDown,!0),win.addEventListener("keydown",this._onKeyDown,!0),win.addEventListener("tabster:groupper:movefocus",this._onMoveFocus)},this._onGroupperDispose=groupper=>{delete this._grouppers[groupper.id]},this._onFocus=element=>{element&&this._updateCurrent(element,!0,!0)},this._onMouseDown=e=>{e.target&&this._updateCurrent(e.target,!0)},this._onKeyDown=event=>{if(event.key!==Keys_Enter&&event.key!==Keys_Escape)return;if(event.ctrlKey||event.altKey||event.shiftKey||event.metaKey)return;const element=this._tabster.focusedElement.getFocusedElement();element&&this.handleKeyPress(element,event)},this._onMoveFocus=e=>{var _a;const element=e.composedPath()[0],action=null===(_a=e.detail)||void 0===_a?void 0:_a.action;element&&void 0!==action&&!e.defaultPrevented&&(action===GroupperMoveFocusActions.Enter?this._enterGroupper(element):this._escapeGroupper(element),e.stopImmediatePropagation())},this._tabster=tabster,this._win=getWindow,tabster.queueInit(this._init)}dispose(){const win=this._win();this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources_EscapeGroupper),this._current={},this._updateTimer&&(win.clearTimeout(this._updateTimer),delete this._updateTimer),this._tabster.focusedElement.unsubscribe(this._onFocus),win.document.removeEventListener("mousedown",this._onMouseDown,!0),win.removeEventListener("keydown",this._onKeyDown,!0),win.removeEventListener("tabster:groupper:movefocus",this._onMoveFocus),Object.keys(this._grouppers).forEach((groupperId=>{this._grouppers[groupperId]&&(this._grouppers[groupperId].dispose(),delete this._grouppers[groupperId])}))}createGroupper(element,props,sys){const newGroupper=new Groupper(this._tabster,element,this._onGroupperDispose,props,sys);this._grouppers[newGroupper.id]=newGroupper;const focusedElement=this._tabster.focusedElement.getFocusedElement();return focusedElement&&dom.nodeContains(element,focusedElement)&&!this._updateTimer&&(this._updateTimer=this._win().setTimeout((()=>{delete this._updateTimer,focusedElement===this._tabster.focusedElement.getFocusedElement()&&this._updateCurrent(focusedElement,!0,!0)}),0)),newGroupper}forgetCurrentGrouppers(){this._current={}}_updateCurrent(element,includeTarget,checkTarget){var _a;this._updateTimer&&(this._win().clearTimeout(this._updateTimer),delete this._updateTimer);const newIds={};let isTarget=!0;for(let el=element;el;el=dom.getParentElement(el)){const groupper=null===(_a=getTabsterOnElement(this._tabster,el))||void 0===_a?void 0:_a.groupper;if(groupper){if(newIds[groupper.id]=!0,isTarget&&checkTarget&&el!==element&&(isTarget=!1),includeTarget||!isTarget){this._current[groupper.id]=groupper;const isTabbable=groupper.isActive()||element!==el&&(!groupper.getProps().delegated||groupper.getFirst(!1)!==element);groupper.makeTabbable(isTabbable)}isTarget=!1}}for(const id of Object.keys(this._current)){const groupper=this._current[id];groupper.id in newIds||(groupper.makeTabbable(!1),groupper.setFirst(void 0),delete this._current[id])}}_enterGroupper(element,relatedEvent){const tabster=this._tabster,ctx=RootAPI.getTabsterContext(tabster,element),groupper=(null==ctx?void 0:ctx.groupper)||(null==ctx?void 0:ctx.modalizerInGroupper),groupperElement=null==groupper?void 0:groupper.getElement();if(groupper&&groupperElement&&(element===groupperElement||groupper.getProps().delegated&&element===groupper.getFirst(!1))){const next=tabster.focusable.findNext({container:groupperElement,currentElement:element,useActiveModalizer:!0});if(next&&(!relatedEvent||relatedEvent&&groupperElement.dispatchEvent(new TabsterMoveFocusEvent({by:"groupper",owner:groupperElement,next,relatedEvent}))))return relatedEvent&&(relatedEvent.preventDefault(),relatedEvent.stopImmediatePropagation()),next.focus(),next}return null}_escapeGroupper(element,relatedEvent,fromModalizer){var _a;const tabster=this._tabster,ctx=RootAPI.getTabsterContext(tabster,element),modalizerInGroupper=null==ctx?void 0:ctx.modalizerInGroupper;let groupper=(null==ctx?void 0:ctx.groupper)||modalizerInGroupper;const groupperElement=null==groupper?void 0:groupper.getElement();if(groupper&&groupperElement&&dom.nodeContains(groupperElement,element)){let next;if(element!==groupperElement||fromModalizer)next=groupper.getFirst(!0);else{const parentElement=dom.getParentElement(groupperElement),parentCtx=parentElement?RootAPI.getTabsterContext(tabster,parentElement):void 0;groupper=null==parentCtx?void 0:parentCtx.groupper,next=null==groupper?void 0:groupper.getFirst(!0)}if(next&&(!relatedEvent||relatedEvent&&groupperElement.dispatchEvent(new TabsterMoveFocusEvent({by:"groupper",owner:groupperElement,next,relatedEvent}))))return groupper&&(groupper.makeTabbable(!1),modalizerInGroupper&&(null===(_a=tabster.modalizer)||void 0===_a||_a.setActive(void 0))),next.focus(),next}return null}moveFocus(element,action){return action===GroupperMoveFocusActions.Enter?this._enterGroupper(element):this._escapeGroupper(element)}handleKeyPress(element,event,fromModalizer){const tabster=this._tabster,ctx=RootAPI.getTabsterContext(tabster,element);if(ctx&&((null==ctx?void 0:ctx.groupper)||(null==ctx?void 0:ctx.modalizerInGroupper))){if(tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources_EscapeGroupper),ctx.ignoreKeydown(event))return;if(event.key===Keys_Enter)this._enterGroupper(element,event);else if(event.key===Keys_Escape){const focusedElement=tabster.focusedElement.getFocusedElement();tabster.focusedElement.requestAsyncFocus(AsyncFocusSources_EscapeGroupper,(()=>{(focusedElement===tabster.focusedElement.getFocusedElement()||(!fromModalizer||focusedElement)&&fromModalizer)&&this._escapeGroupper(element,event,fromModalizer)}),0)}}}}class KeyboardNavigationState extends Subscribable{constructor(getWindow){super(),this._onChange=isNavigatingWithKeyboard=>{this.setVal(isNavigatingWithKeyboard,void 0)},this._keyborg=(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.SQ)(getWindow()),this._keyborg.subscribe(this._onChange)}dispose(){super.dispose(),this._keyborg&&(this._keyborg.unsubscribe(this._onChange),(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.bd)(this._keyborg),delete this._keyborg)}setNavigatingWithKeyboard(isNavigatingWithKeyboard){var _a;null===(_a=this._keyborg)||void 0===_a||_a.setVal(isNavigatingWithKeyboard)}isNavigatingWithKeyboard(){var _a;return!!(null===(_a=this._keyborg)||void 0===_a?void 0:_a.isNavigatingWithKeyboard())}}let _wasFocusedCounter=0;class ModalizerDummyManager extends DummyInputManager{constructor(element,tabster,sys){super(tabster,element,DummyInputManagerPriorities_Modalizer,sys),this._setHandlers(((dummyInput,isBackward)=>{var _a,_b;const el=element.get(),container=el&&(null===(_a=RootAPI.getRoot(tabster,el))||void 0===_a?void 0:_a.getElement()),input=dummyInput.input;let toFocus;if(container&&input){const dummyContainer=getDummyInputContainer(input),ctx=RootAPI.getTabsterContext(tabster,dummyContainer||input);ctx&&(toFocus=null===(_b=FocusedElementState.findNextTabbable(tabster,ctx,container,input,void 0,isBackward,!0))||void 0===_b?void 0:_b.element),toFocus&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(toFocus)}}))}}class Modalizer extends TabsterPart{constructor(tabster,element,onDispose,props,sys,activeElements){super(tabster,element,props),this._wasFocused=0,this.userId=props.id,this._onDispose=onDispose,this._activeElements=activeElements,tabster.controlTab||(this.dummyManager=new ModalizerDummyManager(this._element,tabster,sys))}makeActive(isActive){if(this._isActive!==isActive){this._isActive=isActive;const element=this.getElement();if(element){const activeElements=this._activeElements,index=activeElements.map((e=>e.get())).indexOf(element);isActive?index<0&&activeElements.push(new WeakHTMLElement(this._tabster.getWindow,element)):index>=0&&activeElements.splice(index,1)}0,this._dispatchEvent(isActive)}}focused(noIncrement){return noIncrement||(this._wasFocused=++_wasFocusedCounter),this._wasFocused}setProps(props){props.id&&(this.userId=props.id),this._props={...props}}dispose(){var _a;this.makeActive(!1),this._onDispose(this),null===(_a=this.dummyManager)||void 0===_a||_a.dispose(),delete this.dummyManager,this._activeElements=[],this._remove()}isActive(){return!!this._isActive}contains(element){return dom.nodeContains(this.getElement(),element)}findNextTabbable(currentElement,referenceElement,isBackward,ignoreAccessibility){var _a,_b;if(!this.getElement())return null;const tabster=this._tabster;let uncontrolled,next=null,outOfDOMOrder=!1;const container=currentElement&&(null===(_a=RootAPI.getRoot(tabster,currentElement))||void 0===_a?void 0:_a.getElement());if(container){const findProps={container,currentElement,referenceElement,ignoreAccessibility,useActiveModalizer:!0},findPropsOut={};next=tabster.focusable[isBackward?"findPrev":"findNext"](findProps,findPropsOut),!next&&this._props.isTrapped&&(null===(_b=tabster.modalizer)||void 0===_b?void 0:_b.activeId)?(next=tabster.focusable[isBackward?"findLast":"findFirst"]({container,ignoreAccessibility,useActiveModalizer:!0},findPropsOut),null===next&&(next=currentElement),outOfDOMOrder=!0):outOfDOMOrder=!!findPropsOut.outOfDOMOrder,uncontrolled=findPropsOut.uncontrolled}return{element:next,uncontrolled,outOfDOMOrder}}_dispatchEvent(isActive,allElements){const element=this.getElement();let defaultPrevented=!1;if(element){const elements=allElements?this._activeElements.map((e=>e.get())):[element];for(const el of elements)if(el){const eventDetail={id:this.userId,element},event=isActive?new ModalizerActiveEvent(eventDetail):new ModalizerInactiveEvent(eventDetail);el.dispatchEvent(event),event.defaultPrevented&&(defaultPrevented=!0)}}return defaultPrevented}_remove(){0}}class ModalizerAPI{constructor(tabster,alwaysAccessibleSelector,accessibleCheck){this._onModalizerDispose=modalizer=>{const id=modalizer.id,userId=modalizer.userId,part=this._parts[userId];delete this._modalizers[id],part&&(delete part[id],0===Object.keys(part).length&&(delete this._parts[userId],this.activeId===userId&&this.setActive(void 0)))},this._onKeyDown=event=>{var _a;if(event.key!==Keys_Escape)return;const tabster=this._tabster,element=tabster.focusedElement.getFocusedElement();if(element){const ctx=RootAPI.getTabsterContext(tabster,element),modalizer=null==ctx?void 0:ctx.modalizer;if(ctx&&!ctx.groupper&&(null==modalizer?void 0:modalizer.isActive())&&!ctx.ignoreKeydown(event)){const activeId=modalizer.userId;if(activeId){const part=this._parts[activeId];if(part){const focusedSince=Object.keys(part).map((id=>{var _a;const m=part[id],el=m.getElement();let groupper;return el&&(groupper=null===(_a=getTabsterOnElement(this._tabster,el))||void 0===_a?void 0:_a.groupper),m&&el&&groupper?{el,focusedSince:m.focused(!0)}:{focusedSince:0}})).filter((f=>f.focusedSince>0)).sort(((a,b)=>a.focusedSince>b.focusedSince?-1:a.focusedSince<b.focusedSince?1:0));if(focusedSince.length){const groupperElement=focusedSince[0].el;groupperElement&&(null===(_a=tabster.groupper)||void 0===_a||_a.handleKeyPress(groupperElement,event,!0))}}}}}},this._onFocus=(focusedElement,detail)=>{var _a,_b;const ctx=focusedElement&&RootAPI.getTabsterContext(this._tabster,focusedElement);if(!ctx||!focusedElement)return;const augmentedMap=this._augMap;for(let e=focusedElement;e;e=dom.getParentElement(e))augmentedMap.has(e)&&(augmentedMap.delete(e),augmentAttribute(this._tabster,e,"aria-hidden"));const modalizer=ctx.modalizer;if(null===(_b=modalizer||(null===(_a=getTabsterOnElement(this._tabster,focusedElement))||void 0===_a?void 0:_a.modalizer))||void 0===_b||_b.focused(),(null==modalizer?void 0:modalizer.userId)!==this.activeId)if(detail.isFocusedProgrammatically||this.currentIsOthersAccessible||(null==modalizer?void 0:modalizer.getProps().isAlwaysAccessible))this.setActive(modalizer);else{const win=this._win();win.clearTimeout(this._restoreModalizerFocusTimer),this._restoreModalizerFocusTimer=win.setTimeout((()=>this._restoreModalizerFocus(focusedElement)),100)}else this.currentIsOthersAccessible=null==modalizer?void 0:modalizer.getProps().isOthersAccessible},this._tabster=tabster,this._win=tabster.getWindow,this._modalizers={},this._parts={},this._augMap=new WeakMap,this._aug=[],this._alwaysAccessibleSelector=alwaysAccessibleSelector,this._accessibleCheck=accessibleCheck,this.activeElements=[],tabster.controlTab||tabster.root.addDummyInputs();this._win().addEventListener("keydown",this._onKeyDown,!0),tabster.queueInit((()=>{this._tabster.focusedElement.subscribe(this._onFocus)}))}dispose(){const win=this._win();win.removeEventListener("keydown",this._onKeyDown,!0),Object.keys(this._modalizers).forEach((modalizerId=>{this._modalizers[modalizerId]&&(this._modalizers[modalizerId].dispose(),delete this._modalizers[modalizerId])})),win.clearTimeout(this._restoreModalizerFocusTimer),win.clearTimeout(this._hiddenUpdateTimer),this._parts={},delete this.activeId,this.activeElements=[],this._augMap=new WeakMap,this._aug=[],this._tabster.focusedElement.unsubscribe(this._onFocus)}createModalizer(element,props,sys){var _a;const modalizer=new Modalizer(this._tabster,element,this._onModalizerDispose,props,sys,this.activeElements),id=modalizer.id,userId=props.id;this._modalizers[id]=modalizer;let part=this._parts[userId];return part||(part=this._parts[userId]={}),part[id]=modalizer,dom.nodeContains(element,null!==(_a=this._tabster.focusedElement.getFocusedElement())&&void 0!==_a?_a:null)&&(userId!==this.activeId?this.setActive(modalizer):modalizer.makeActive(!0)),modalizer}isAugmented(element){return this._augMap.has(element)}hiddenUpdate(){this._hiddenUpdateTimer||(this._hiddenUpdateTimer=this._win().setTimeout((()=>{delete this._hiddenUpdateTimer,this._hiddenUpdate()}),250))}setActive(modalizer){const userId=null==modalizer?void 0:modalizer.userId,activeId=this.activeId;if(activeId!==userId){if(this.activeId=userId,activeId){const part=this._parts[activeId];if(part)for(const id of Object.keys(part))part[id].makeActive(!1)}if(userId){const part=this._parts[userId];if(part)for(const id of Object.keys(part))part[id].makeActive(!0)}this.currentIsOthersAccessible=null==modalizer?void 0:modalizer.getProps().isOthersAccessible,this.hiddenUpdate()}}focus(elementFromModalizer,noFocusFirst,noFocusDefault){const ctx=RootAPI.getTabsterContext(this._tabster,elementFromModalizer),modalizer=null==ctx?void 0:ctx.modalizer;if(modalizer){this.setActive(modalizer);const props=modalizer.getProps(),modalizerRoot=modalizer.getElement();if(modalizerRoot){if(void 0===noFocusFirst&&(noFocusFirst=props.isNoFocusFirst),!noFocusFirst&&this._tabster.keyboardNavigation.isNavigatingWithKeyboard()&&this._tabster.focusedElement.focusFirst({container:modalizerRoot}))return!0;if(void 0===noFocusDefault&&(noFocusDefault=props.isNoFocusDefault),!noFocusDefault&&this._tabster.focusedElement.focusDefault(modalizerRoot))return!0;this._tabster.focusedElement.resetFocus(modalizerRoot)}}else 0;return!1}acceptElement(element,state){var _a;const modalizerUserId=state.modalizerUserId,currentModalizer=null===(_a=state.currentCtx)||void 0===_a?void 0:_a.modalizer;if(modalizerUserId)for(const e of this.activeElements){const el=e.get();if(el&&(dom.nodeContains(element,el)||el===element))return NodeFilter.FILTER_SKIP}const ret=modalizerUserId===(null==currentModalizer?void 0:currentModalizer.userId)||!modalizerUserId&&(null==currentModalizer?void 0:currentModalizer.getProps().isAlwaysAccessible)?void 0:NodeFilter.FILTER_SKIP;return void 0!==ret&&(state.skippedFocusable=!0),ret}_hiddenUpdate(){var _a;const tabster=this._tabster,body=tabster.getWindow().document.body,activeId=this.activeId,parts=this._parts,visibleElements=[],hiddenElements=[],alwaysAccessibleSelector=this._alwaysAccessibleSelector,alwaysAccessibleElements=alwaysAccessibleSelector?Array.from(dom.querySelectorAll(body,alwaysAccessibleSelector)):[],activeModalizerElements=[];for(const userId of Object.keys(parts)){const modalizerParts=parts[userId];for(const id of Object.keys(modalizerParts)){const modalizer=modalizerParts[id],el=modalizer.getElement(),isAlwaysAccessible=modalizer.getProps().isAlwaysAccessible;el&&(userId===activeId?(activeModalizerElements.push(el),this.currentIsOthersAccessible||visibleElements.push(el)):isAlwaysAccessible?alwaysAccessibleElements.push(el):hiddenElements.push(el))}}const augmentedMap=this._augMap,allVisibleElements=visibleElements.length>0?[...visibleElements,...alwaysAccessibleElements]:void 0,newAugmented=[],newAugmentedMap=new WeakMap,toggle=(element,hide)=>{var _a;const tagName=element.tagName;if("SCRIPT"===tagName||"STYLE"===tagName)return;let isAugmented=!1;augmentedMap.has(element)?hide?isAugmented=!0:(augmentedMap.delete(element),augmentAttribute(tabster,element,"aria-hidden")):hide&&!(null===(_a=this._accessibleCheck)||void 0===_a?void 0:_a.call(this,element,activeModalizerElements))&&augmentAttribute(tabster,element,"aria-hidden","true")&&(augmentedMap.set(element,!0),isAugmented=!0),isAugmented&&(newAugmented.push(new WeakHTMLElement(tabster.getWindow,element)),newAugmentedMap.set(element,!0))},walk=element=>{var _a;for(let el=dom.getFirstElementChild(element);el;el=dom.getNextElementSibling(el)){let skip=!1,containsModalizer=!1,containedByModalizer=!1;if(allVisibleElements){const elParent=tabster.getParent(el);for(const c of allVisibleElements){if(el===c){skip=!0;break}if(dom.nodeContains(el,c)){containsModalizer=!0;break}dom.nodeContains(c,elParent)&&(containedByModalizer=!0)}containsModalizer||(null===(_a=el.__tabsterElementFlags)||void 0===_a?void 0:_a.noDirectAriaHidden)?walk(el):skip||containedByModalizer||toggle(el,!0)}else toggle(el,!1)}};allVisibleElements||alwaysAccessibleElements.forEach((e=>toggle(e,!1))),hiddenElements.forEach((e=>toggle(e,!0))),body&&walk(body),null===(_a=this._aug)||void 0===_a||_a.map((e=>e.get())).forEach((e=>{e&&!newAugmentedMap.get(e)&&toggle(e,!1)})),this._aug=newAugmented,this._augMap=newAugmentedMap}_restoreModalizerFocus(outsideElement){const ownerDocument=null==outsideElement?void 0:outsideElement.ownerDocument;if(!outsideElement||!ownerDocument)return;const ctx=RootAPI.getTabsterContext(this._tabster,outsideElement),modalizer=null==ctx?void 0:ctx.modalizer,activeId=this.activeId;if(!modalizer&&!activeId||modalizer&&activeId===modalizer.userId)return;const container=null==ctx?void 0:ctx.root.getElement();if(container){let toFocus=this._tabster.focusable.findFirst({container,useActiveModalizer:!0});if(toFocus){if(outsideElement.compareDocumentPosition(toFocus)&document.DOCUMENT_POSITION_PRECEDING&&(toFocus=this._tabster.focusable.findLast({container,useActiveModalizer:!0}),!toFocus))throw new Error("Something went wrong.");return void this._tabster.focusedElement.focus(toFocus)}}outsideElement.blur()}}const _inputSelector=["input","textarea","*[contenteditable]"].join(", ");class MoverDummyManager extends DummyInputManager{constructor(element,tabster,getMemorized,sys){super(tabster,element,DummyInputManagerPriorities_Mover,sys),this._onFocusDummyInput=dummyInput=>{var _a,_b;const container=this._element.get(),input=dummyInput.input;if(container&&input){const ctx=RootAPI.getTabsterContext(this._tabster,container);let toFocus;ctx&&(toFocus=null===(_a=FocusedElementState.findNextTabbable(this._tabster,ctx,void 0,input,void 0,!dummyInput.isFirst,!0))||void 0===_a?void 0:_a.element);const memorized=null===(_b=this._getMemorized())||void 0===_b?void 0:_b.get();memorized&&this._tabster.focusable.isFocusable(memorized)&&(toFocus=memorized),toFocus&&(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(toFocus)}},this._tabster=tabster,this._getMemorized=getMemorized,this._setHandlers(this._onFocusDummyInput)}}class Mover extends TabsterPart{constructor(tabster,element,onDispose,props,sys){var _a;super(tabster,element,props),this._visible={},this._onIntersection=entries=>{for(const entry of entries){const el=entry.target,id=getElementUId(this._win,el);let newVisibility,fullyVisible=this._fullyVisible;if(entry.intersectionRatio>=.25?(newVisibility=entry.intersectionRatio>=.75?Visibilities_Visible:Visibilities_PartiallyVisible,newVisibility===Visibilities_Visible&&(fullyVisible=id)):newVisibility=Visibilities_Invisible,this._visible[id]!==newVisibility){void 0===newVisibility?(delete this._visible[id],fullyVisible===id&&delete this._fullyVisible):(this._visible[id]=newVisibility,this._fullyVisible=fullyVisible);const state=this.getState(el);state&&el.dispatchEvent(new MoverStateEvent(state))}}},this._win=tabster.getWindow,this.visibilityTolerance=null!==(_a=props.visibilityTolerance)&&void 0!==_a?_a:.8,(this._props.trackState||this._props.visibilityAware)&&(this._intersectionObserver=new IntersectionObserver(this._onIntersection,{threshold:[0,.25,.5,.75,1]}),this._observeState()),this._onDispose=onDispose;const getMemorized=()=>props.memorizeCurrent?this._current:void 0;tabster.controlTab||(this.dummyManager=new MoverDummyManager(this._element,tabster,getMemorized,sys))}dispose(){var _a;this._onDispose(this),this._intersectionObserver&&(this._intersectionObserver.disconnect(),delete this._intersectionObserver),delete this._current,delete this._fullyVisible,delete this._allElements,delete this._updateQueue,this._unobserve&&(this._unobserve(),delete this._unobserve);const win=this._win();this._setCurrentTimer&&(win.clearTimeout(this._setCurrentTimer),delete this._setCurrentTimer),this._updateTimer&&(win.clearTimeout(this._updateTimer),delete this._updateTimer),null===(_a=this.dummyManager)||void 0===_a||_a.dispose(),delete this.dummyManager}setCurrent(element){this._current=element?new WeakHTMLElement(this._win,element):void 0,!this._props.trackState&&!this._props.visibilityAware||this._setCurrentTimer||(this._setCurrentTimer=this._win().setTimeout((()=>{var _a;delete this._setCurrentTimer;const changed=[];this._current!==this._prevCurrent&&(changed.push(this._current),changed.push(this._prevCurrent),this._prevCurrent=this._current);for(const weak of changed){const el=null==weak?void 0:weak.get();if(el&&(null===(_a=this._allElements)||void 0===_a?void 0:_a.get(el))===this){const props=this._props;if(el&&(void 0!==props.visibilityAware||props.trackState)){const state=this.getState(el);state&&el.dispatchEvent(new MoverStateEvent(state))}}}})))}getCurrent(){var _a;return(null===(_a=this._current)||void 0===_a?void 0:_a.get())||null}findNextTabbable(currentElement,referenceElement,isBackward,ignoreAccessibility){const container=this.getElement(),currentIsDummy=container&&getDummyInputContainer(currentElement)===container;if(!container)return null;let uncontrolled,next=null,outOfDOMOrder=!1;if(this._props.tabbable||currentIsDummy||currentElement&&!dom.nodeContains(container,currentElement)){const findProps={currentElement,referenceElement,container,ignoreAccessibility,useActiveModalizer:!0},findPropsOut={};next=this._tabster.focusable[isBackward?"findPrev":"findNext"](findProps,findPropsOut),outOfDOMOrder=!!findPropsOut.outOfDOMOrder,uncontrolled=findPropsOut.uncontrolled}return{element:next,uncontrolled,outOfDOMOrder}}acceptElement(element,state){var _a,_b;if(!FocusedElementState.isTabbing)return(null===(_a=state.currentCtx)||void 0===_a?void 0:_a.excludedFromMover)?NodeFilter.FILTER_REJECT:void 0;const{memorizeCurrent,visibilityAware,hasDefault=!0}=this._props,moverElement=this.getElement();if(moverElement&&(memorizeCurrent||visibilityAware||hasDefault)&&(!dom.nodeContains(moverElement,state.from)||getDummyInputContainer(state.from)===moverElement)){let found;if(memorizeCurrent){const current=null===(_b=this._current)||void 0===_b?void 0:_b.get();current&&state.acceptCondition(current)&&(found=current)}if(!found&&hasDefault&&(found=this._tabster.focusable.findDefault({container:moverElement,useActiveModalizer:!0})),!found&&visibilityAware&&(found=this._tabster.focusable.findElement({container:moverElement,useActiveModalizer:!0,isBackward:state.isBackward,acceptCondition:el=>{var _a;const id=getElementUId(this._win,el),visibility=this._visible[id];return moverElement!==el&&!!(null===(_a=this._allElements)||void 0===_a?void 0:_a.get(el))&&state.acceptCondition(el)&&(visibility===Visibilities_Visible||visibility===Visibilities_PartiallyVisible&&(visibilityAware===Visibilities_PartiallyVisible||!this._fullyVisible))}})),found)return state.found=!0,state.foundElement=found,state.rejectElementsFrom=moverElement,state.skippedFocusable=!0,NodeFilter.FILTER_ACCEPT}}_observeState(){const element=this.getElement();if(this._unobserve||!element||"undefined"==typeof MutationObserver)return;const win=this._win(),allElements=this._allElements=new WeakMap,tabsterFocusable=this._tabster.focusable;let updateQueue=this._updateQueue=[];const observer=dom.createMutationObserver((mutations=>{for(const mutation of mutations){const target=mutation.target,removed=mutation.removedNodes,added=mutation.addedNodes;if("attributes"===mutation.type)"tabindex"===mutation.attributeName&&updateQueue.push({element:target,type:2});else{for(let i=0;i<removed.length;i++)updateQueue.push({element:removed[i],type:3});for(let i=0;i<added.length;i++)updateQueue.push({element:added[i],type:1})}}requestUpdate()})),setElement=(element,remove)=>{var _a,_b;const current=allElements.get(element);current&&remove&&(null===(_a=this._intersectionObserver)||void 0===_a||_a.unobserve(element),allElements.delete(element)),current||remove||(allElements.set(element,this),null===(_b=this._intersectionObserver)||void 0===_b||_b.observe(element))},updateElement=element=>{const isFocusable=tabsterFocusable.isFocusable(element);allElements.get(element)?isFocusable||setElement(element,!0):isFocusable&&setElement(element)},addNewElements=element=>{const{mover}=getMoverGroupper(element);if(mover&&mover!==this){if(mover.getElement()!==element||!tabsterFocusable.isFocusable(element))return;setElement(element)}const walker=createElementTreeWalker(win.document,element,(node=>{const{mover,groupper}=getMoverGroupper(node);if(mover&&mover!==this)return NodeFilter.FILTER_REJECT;const groupperFirstFocusable=null==groupper?void 0:groupper.getFirst(!0);return groupper&&groupper.getElement()!==node&&groupperFirstFocusable&&groupperFirstFocusable!==node?NodeFilter.FILTER_REJECT:(tabsterFocusable.isFocusable(node)&&setElement(node),NodeFilter.FILTER_SKIP)}));if(walker)for(walker.currentNode=element;walker.nextNode(););},removeWalk=element=>{allElements.get(element)&&setElement(element,!0);for(let el=dom.getFirstElementChild(element);el;el=dom.getNextElementSibling(el))removeWalk(el)},requestUpdate=()=>{!this._updateTimer&&updateQueue.length&&(this._updateTimer=win.setTimeout((()=>{delete this._updateTimer;for(const{element,type}of updateQueue)switch(type){case 2:updateElement(element);break;case 1:addNewElements(element);break;case 3:removeWalk(element)}updateQueue=this._updateQueue=[]}),0))},getMoverGroupper=element=>{const ret={};for(let el=element;el;el=dom.getParentElement(el)){const toe=getTabsterOnElement(this._tabster,el);if(toe&&(toe.groupper&&!ret.groupper&&(ret.groupper=toe.groupper),toe.mover)){ret.mover=toe.mover;break}}return ret};updateQueue.push({element,type:1}),requestUpdate(),observer.observe(element,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["tabindex"]}),this._unobserve=()=>{observer.disconnect()}}getState(element){const id=getElementUId(this._win,element);if(id in this._visible){const visibility=this._visible[id]||Visibilities_Invisible;return{isCurrent:this._current?this._current.get()===element:void 0,visibility}}}}class MoverAPI{constructor(tabster,getWindow){this._init=()=>{const win=this._win();win.addEventListener("keydown",this._onKeyDown,!0),win.addEventListener("tabster:mover:movefocus",this._onMoveFocus),win.addEventListener("tabster:mover:memorized-element",this._onMemorizedElement),this._tabster.focusedElement.subscribe(this._onFocus)},this._onMoverDispose=mover=>{delete this._movers[mover.id]},this._onFocus=element=>{var _a;let currentFocusableElement=element,deepestFocusableElement=element;for(let el=dom.getParentElement(element);el;el=dom.getParentElement(el)){const mover=null===(_a=getTabsterOnElement(this._tabster,el))||void 0===_a?void 0:_a.mover;mover&&(mover.setCurrent(deepestFocusableElement),currentFocusableElement=void 0),!currentFocusableElement&&this._tabster.focusable.isFocusable(el)&&(currentFocusableElement=deepestFocusableElement=el)}},this._onKeyDown=async event=>{var _a;if(this._ignoredInputTimer&&(this._win().clearTimeout(this._ignoredInputTimer),delete this._ignoredInputTimer),null===(_a=this._ignoredInputResolve)||void 0===_a||_a.call(this,!1),event.ctrlKey||event.altKey||event.shiftKey||event.metaKey)return;const key=event.key;let moverKey;if(key===Keys_ArrowDown?moverKey=MoverKeys.ArrowDown:key===Keys_ArrowRight?moverKey=MoverKeys.ArrowRight:key===Keys_ArrowUp?moverKey=MoverKeys.ArrowUp:key===Keys_ArrowLeft?moverKey=MoverKeys.ArrowLeft:key===Keys_PageDown?moverKey=MoverKeys.PageDown:key===Keys_PageUp?moverKey=MoverKeys.PageUp:key===Keys_Home?moverKey=MoverKeys.Home:key===Keys_End&&(moverKey=MoverKeys.End),!moverKey)return;const focused=this._tabster.focusedElement.getFocusedElement();focused&&!await this._isIgnoredInput(focused,key)&&this._moveFocus(focused,moverKey,event)},this._onMoveFocus=e=>{var _a;const element=e.composedPath()[0],key=null===(_a=e.detail)||void 0===_a?void 0:_a.key;element&&void 0!==key&&!e.defaultPrevented&&(this._moveFocus(element,key),e.stopImmediatePropagation())},this._onMemorizedElement=e=>{var _a;const target=e.composedPath()[0];let memorizedElement=null===(_a=e.detail)||void 0===_a?void 0:_a.memorizedElement;if(target){const ctx=RootAPI.getTabsterContext(this._tabster,target),mover=null==ctx?void 0:ctx.mover;mover&&(memorizedElement&&!dom.nodeContains(mover.getElement(),memorizedElement)&&(memorizedElement=void 0),mover.setCurrent(memorizedElement),e.stopImmediatePropagation())}},this._tabster=tabster,this._win=getWindow,this._movers={},tabster.queueInit(this._init)}dispose(){var _a;const win=this._win();this._tabster.focusedElement.unsubscribe(this._onFocus),null===(_a=this._ignoredInputResolve)||void 0===_a||_a.call(this,!1),this._ignoredInputTimer&&(win.clearTimeout(this._ignoredInputTimer),delete this._ignoredInputTimer),win.removeEventListener("keydown",this._onKeyDown,!0),win.removeEventListener("tabster:mover:movefocus",this._onMoveFocus),win.removeEventListener("tabster:mover:memorized-element",this._onMemorizedElement),Object.keys(this._movers).forEach((moverId=>{this._movers[moverId]&&(this._movers[moverId].dispose(),delete this._movers[moverId])}))}createMover(element,props,sys){const newMover=new Mover(this._tabster,element,this._onMoverDispose,props,sys);return this._movers[newMover.id]=newMover,newMover}moveFocus(fromElement,key){return this._moveFocus(fromElement,key)}_moveFocus(fromElement,key,relatedEvent){var _a,_b;const tabster=this._tabster,ctx=RootAPI.getTabsterContext(tabster,fromElement,{checkRtl:!0});if(!ctx||!ctx.mover||ctx.excludedFromMover||relatedEvent&&ctx.ignoreKeydown(relatedEvent))return null;const mover=ctx.mover,container=mover.getElement();if(ctx.groupperBeforeMover){const groupper=ctx.groupper;if(!groupper||groupper.isActive(!0))return null;for(let el=dom.getParentElement(groupper.getElement());el&&el!==container;el=dom.getParentElement(el))if(null===(_b=null===(_a=getTabsterOnElement(tabster,el))||void 0===_a?void 0:_a.groupper)||void 0===_b?void 0:_b.isActive(!0))return null}if(!container)return null;const focusable=tabster.focusable,moverProps=mover.getProps(),direction=moverProps.direction||MoverDirections.Both,isBoth=direction===MoverDirections.Both,isVertical=isBoth||direction===MoverDirections.Vertical,isHorizontal=isBoth||direction===MoverDirections.Horizontal,isGridLinear=direction===MoverDirections.GridLinear,isGrid=isGridLinear||direction===MoverDirections.Grid,isCyclic=moverProps.cyclic;let next,scrollIntoViewArg,focusedElementRect,focusedElementX1=0,focusedElementX2=0;if(isGrid&&(focusedElementRect=fromElement.getBoundingClientRect(),focusedElementX1=Math.ceil(focusedElementRect.left),focusedElementX2=Math.floor(focusedElementRect.right)),ctx.rtl&&(key===MoverKeys.ArrowRight?key=MoverKeys.ArrowLeft:key===MoverKeys.ArrowLeft&&(key=MoverKeys.ArrowRight)),key===MoverKeys.ArrowDown&&isVertical||key===MoverKeys.ArrowRight&&(isHorizontal||isGrid))if(next=focusable.findNext({currentElement:fromElement,container,useActiveModalizer:!0}),next&&isGrid){const nextElementX1=Math.ceil(next.getBoundingClientRect().left);!isGridLinear&&focusedElementX2>nextElementX1&&(next=void 0)}else!next&&isCyclic&&(next=focusable.findFirst({container,useActiveModalizer:!0}));else if(key===MoverKeys.ArrowUp&&isVertical||key===MoverKeys.ArrowLeft&&(isHorizontal||isGrid))if(next=focusable.findPrev({currentElement:fromElement,container,useActiveModalizer:!0}),next&&isGrid){const nextElementX2=Math.floor(next.getBoundingClientRect().right);!isGridLinear&&nextElementX2>focusedElementX1&&(next=void 0)}else!next&&isCyclic&&(next=focusable.findLast({container,useActiveModalizer:!0}));else if(key===MoverKeys.Home)isGrid?focusable.findElement({container,currentElement:fromElement,useActiveModalizer:!0,isBackward:!0,acceptCondition:el=>{var _a;if(!focusable.isFocusable(el))return!1;const nextElementX1=Math.ceil(null!==(_a=el.getBoundingClientRect().left)&&void 0!==_a?_a:0);return el!==fromElement&&focusedElementX1<=nextElementX1||(next=el,!1)}}):next=focusable.findFirst({container,useActiveModalizer:!0});else if(key===MoverKeys.End)isGrid?focusable.findElement({container,currentElement:fromElement,useActiveModalizer:!0,acceptCondition:el=>{var _a;if(!focusable.isFocusable(el))return!1;const nextElementX1=Math.ceil(null!==(_a=el.getBoundingClientRect().left)&&void 0!==_a?_a:0);return el!==fromElement&&focusedElementX1>=nextElementX1||(next=el,!1)}}):next=focusable.findLast({container,useActiveModalizer:!0});else if(key===MoverKeys.PageUp){if(focusable.findElement({currentElement:fromElement,container,useActiveModalizer:!0,isBackward:!0,acceptCondition:el=>!!focusable.isFocusable(el)&&(!isElementVerticallyVisibleInContainer(this._win,el,mover.visibilityTolerance)||(next=el,!1))}),isGrid&&next){const firstColumnX1=Math.ceil(next.getBoundingClientRect().left);focusable.findElement({currentElement:next,container,useActiveModalizer:!0,acceptCondition:el=>{if(!focusable.isFocusable(el))return!1;const nextElementX1=Math.ceil(el.getBoundingClientRect().left);return focusedElementX1<nextElementX1||firstColumnX1>=nextElementX1||(next=el,!1)}})}scrollIntoViewArg=!1}else if(key===MoverKeys.PageDown){if(focusable.findElement({currentElement:fromElement,container,useActiveModalizer:!0,acceptCondition:el=>!!focusable.isFocusable(el)&&(!isElementVerticallyVisibleInContainer(this._win,el,mover.visibilityTolerance)||(next=el,!1))}),isGrid&&next){const lastColumnX1=Math.ceil(next.getBoundingClientRect().left);focusable.findElement({currentElement:next,container,useActiveModalizer:!0,isBackward:!0,acceptCondition:el=>{if(!focusable.isFocusable(el))return!1;const nextElementX1=Math.ceil(el.getBoundingClientRect().left);return focusedElementX1>nextElementX1||lastColumnX1<=nextElementX1||(next=el,!1)}})}scrollIntoViewArg=!0}else if(isGrid){const isBackward=key===MoverKeys.ArrowUp,ax1=focusedElementX1,ay1=Math.ceil(focusedElementRect.top),ax2=focusedElementX2,ay2=Math.floor(focusedElementRect.bottom);let targetElement,lastDistance,lastIntersection=0;focusable.findAll({container,currentElement:fromElement,isBackward,onElement:el=>{const rect=el.getBoundingClientRect(),bx1=Math.ceil(rect.left),by1=Math.ceil(rect.top),bx2=Math.floor(rect.right),by2=Math.floor(rect.bottom);if(isBackward&&ay1<by2||!isBackward&&ay2>by1)return!0;const xIntersectionWidth=Math.ceil(Math.min(ax2,bx2))-Math.floor(Math.max(ax1,bx1)),minWidth=Math.ceil(Math.min(ax2-ax1,bx2-bx1));if(xIntersectionWidth>0&&minWidth>=xIntersectionWidth){const intersection=xIntersectionWidth/minWidth;intersection>lastIntersection&&(targetElement=el,lastIntersection=intersection)}else if(0===lastIntersection){const distance=function getDistance(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2){const xDistance=ax2<bx1?bx1-ax2:bx2<ax1?ax1-bx2:0,yDistance=ay2<by1?by1-ay2:by2<ay1?ay1-by2:0;return 0===xDistance?yDistance:0===yDistance?xDistance:Math.sqrt(xDistance*xDistance+yDistance*yDistance)}(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2);(void 0===lastDistance||distance<lastDistance)&&(lastDistance=distance,targetElement=el)}else if(lastIntersection>0)return!1;return!0}}),next=targetElement}return next&&(!relatedEvent||relatedEvent&&container.dispatchEvent(new TabsterMoveFocusEvent({by:"mover",owner:container,next,relatedEvent})))?(void 0!==scrollIntoViewArg&&function scrollIntoView(getWindow,element,alignToTop){const container=getScrollableContainer(element);if(container){const containerRect=getBoundingRect(getWindow,container),elementRect=element.getBoundingClientRect();container.scrollTop+=alignToTop?elementRect.top-containerRect.top:elementRect.bottom-containerRect.bottom}}(this._win,next,scrollIntoViewArg),relatedEvent&&(relatedEvent.preventDefault(),relatedEvent.stopImmediatePropagation()),(0,keyborg__WEBPACK_IMPORTED_MODULE_0__.kG)(next),next):null}async _isIgnoredInput(element,key){if("true"===element.getAttribute("aria-expanded")&&element.hasAttribute("aria-activedescendant"))return!0;if(matchesSelector(element,_inputSelector)){let asyncRet,selectionStart=0,selectionEnd=0,textLength=0;if("INPUT"===element.tagName||"TEXTAREA"===element.tagName){const type=element.type,value=element.value;if(textLength=(value||"").length,"email"===type||"number"===type){if(textLength){const selection=dom.getSelection(element);if(selection){const initialLength=selection.toString().length,isBackward=key===Keys_ArrowLeft||key===Keys_ArrowUp;if(selection.modify("extend",isBackward?"backward":"forward","character"),initialLength!==selection.toString().length)return selection.modify("extend",isBackward?"forward":"backward","character"),!0;textLength=0}}}else{const selStart=element.selectionStart;if(null===selStart)return"hidden"===type;selectionStart=selStart||0,selectionEnd=element.selectionEnd||0}}else"true"===element.contentEditable&&(asyncRet=new(getPromise(this._win))((resolve=>{this._ignoredInputResolve=value=>{delete this._ignoredInputResolve,resolve(value)};const win=this._win();this._ignoredInputTimer&&win.clearTimeout(this._ignoredInputTimer);const{anchorNode:prevAnchorNode,focusNode:prevFocusNode,anchorOffset:prevAnchorOffset,focusOffset:prevFocusOffset}=dom.getSelection(element)||{};this._ignoredInputTimer=win.setTimeout((()=>{var _a,_b,_c;delete this._ignoredInputTimer;const{anchorNode,focusNode,anchorOffset,focusOffset}=dom.getSelection(element)||{};if(anchorNode===prevAnchorNode&&focusNode===prevFocusNode&&anchorOffset===prevAnchorOffset&&focusOffset===prevFocusOffset){if(selectionStart=anchorOffset||0,selectionEnd=focusOffset||0,textLength=(null===(_b=element.textContent)||void 0===_b?void 0:_b.length)||0,anchorNode&&focusNode&&dom.nodeContains(element,anchorNode)&&dom.nodeContains(element,focusNode)&&anchorNode!==element){let anchorFound=!1;const addOffsets=node=>{if(node===anchorNode)anchorFound=!0;else if(node===focusNode)return!0;const nodeText=node.textContent;if(nodeText&&!dom.getFirstChild(node)){const len=nodeText.length;anchorFound?focusNode!==anchorNode&&(selectionEnd+=len):(selectionStart+=len,selectionEnd+=len)}let stop=!1;for(let e=dom.getFirstChild(node);e&&!stop;e=e.nextSibling)stop=addOffsets(e);return stop};addOffsets(element)}null===(_c=this._ignoredInputResolve)||void 0===_c||_c.call(this,!0)}else null===(_a=this._ignoredInputResolve)||void 0===_a||_a.call(this,!1)}),0)})));if(asyncRet&&!await asyncRet)return!0;if(selectionStart!==selectionEnd)return!0;if(selectionStart>0&&(key===Keys_ArrowLeft||key===Keys_ArrowUp||key===Keys_Home))return!0;if(selectionStart<textLength&&(key===Keys_ArrowRight||key===Keys_ArrowDown||key===Keys_End))return!0}return!1}}class UncontrolledAPI{constructor(isUncontrolledCompletely){this._isUncontrolledCompletely=isUncontrolledCompletely}isUncontrolledCompletely(element,completely){var _a;const isUncontrolledCompletely=null===(_a=this._isUncontrolledCompletely)||void 0===_a?void 0:_a.call(this,element,completely);return void 0===isUncontrolledCompletely?completely:isUncontrolledCompletely}}class Restorer extends TabsterPart{constructor(tabster,element,props){var _a;if(super(tabster,element,props),this._hasFocus=!1,this._onFocusOut=e=>{var _a;const element=null===(_a=this._element)||void 0===_a?void 0:_a.get();element&&null===e.relatedTarget&&element.dispatchEvent(new RestorerRestoreFocusEvent),element&&!dom.nodeContains(element,e.relatedTarget)&&(this._hasFocus=!1)},this._onFocusIn=()=>{this._hasFocus=!0},this._props.type===RestorerTypes.Source){const element=null===(_a=this._element)||void 0===_a?void 0:_a.get();null==element||element.addEventListener("focusout",this._onFocusOut),null==element||element.addEventListener("focusin",this._onFocusIn),this._hasFocus=dom.nodeContains(element,element&&dom.getActiveElement(element.ownerDocument))}}dispose(){var _a;if(this._props.type===RestorerTypes.Source){const element=null===(_a=this._element)||void 0===_a?void 0:_a.get();if(null==element||element.removeEventListener("focusout",this._onFocusOut),null==element||element.removeEventListener("focusin",this._onFocusIn),this._hasFocus){this._tabster.getWindow().document.body.dispatchEvent(new RestorerRestoreFocusEvent)}}}}class History{constructor(getWindow){this._stack=[],this._getWindow=getWindow}push(element){var _a;(null===(_a=this._stack[this._stack.length-1])||void 0===_a?void 0:_a.get())!==element&&(this._stack.length>History.DEPTH&&this._stack.shift(),this._stack.push(new WeakHTMLElement(this._getWindow,element)))}pop(filter){var _a;void 0===filter&&(filter=()=>!0);const doc=this._getWindow().document;for(let index=this._stack.length-1;index>=0;index--){const maybeElement=null===(_a=this._stack.pop())||void 0===_a?void 0:_a.get();if(maybeElement&&dom.nodeContains(doc.body,dom.getParentElement(maybeElement))&&filter(maybeElement))return maybeElement}}}History.DEPTH=10;class RestorerAPI{constructor(tabster){this._onRestoreFocus=e=>{var _a,_b;this._focusedElementState.cancelAsyncFocus(AsyncFocusSources_Restorer);const source=e.composedPath()[0];if(source){const sourceId=null===(_b=null===(_a=getTabsterOnElement(this._tabster,source))||void 0===_a?void 0:_a.restorer)||void 0===_b?void 0:_b.getProps().id;this._focusedElementState.requestAsyncFocus(AsyncFocusSources_Restorer,(()=>this._restoreFocus(source,sourceId)),0)}},this._onFocusIn=element=>{var _a;if(!element)return;const tabsterAttribute=getTabsterOnElement(this._tabster,element);(null===(_a=null==tabsterAttribute?void 0:tabsterAttribute.restorer)||void 0===_a?void 0:_a.getProps().type)===RestorerTypes.Target&&this._history.push(element)},this._restoreFocus=(source,sourceId)=>{var _a;const doc=this._getWindow().document;if(dom.getActiveElement(doc)!==doc.body)return;if(!this._keyboardNavState.isNavigatingWithKeyboard()&&dom.nodeContains(doc.body,source))return;const getId=element=>{var _a,_b;return null===(_b=null===(_a=getTabsterOnElement(this._tabster,element))||void 0===_a?void 0:_a.restorer)||void 0===_b?void 0:_b.getProps().id};null===(_a=this._history.pop((target=>sourceId===getId(target))))||void 0===_a||_a.focus()},this._tabster=tabster,this._getWindow=tabster.getWindow,this._getWindow().addEventListener("tabster:restorer:restore-focus",this._onRestoreFocus),this._history=new History(this._getWindow),this._keyboardNavState=tabster.keyboardNavigation,this._focusedElementState=tabster.focusedElement,this._focusedElementState.subscribe(this._onFocusIn)}dispose(){const win=this._getWindow();this._focusedElementState.unsubscribe(this._onFocusIn),this._focusedElementState.cancelAsyncFocus(AsyncFocusSources_Restorer),win.removeEventListener("tabster:restorer:restore-focus",this._onRestoreFocus)}createRestorer(element,props){const restorer=new Restorer(this._tabster,element,props);return props.type===RestorerTypes.Target&&dom.getActiveElement(element.ownerDocument)===element&&this._history.push(element),restorer}}function nodeContains(node,otherNode){var _a,_b;if(!node||!otherNode)return!1;let currentNode=otherNode;for(;currentNode;){if(currentNode===node)return!0;currentNode="function"!=typeof currentNode.assignedElements&&(null===(_a=currentNode.assignedSlot)||void 0===_a?void 0:_a.parentNode)?null===(_b=currentNode.assignedSlot)||void 0===_b?void 0:_b.parentNode:currentNode.nodeType===document.DOCUMENT_FRAGMENT_NODE?currentNode.host:currentNode.parentNode}return!1}class ShadowMutationObserver{static _overrideAttachShadow(win){const origAttachShadow=win.Element.prototype.attachShadow;origAttachShadow.__origAttachShadow||(Element.prototype.attachShadow=function(options){const shadowRoot=origAttachShadow.call(this,options);for(const shadowObserver of ShadowMutationObserver._shadowObservers)shadowObserver._addSubObserver(shadowRoot);return shadowRoot},Element.prototype.attachShadow.__origAttachShadow=origAttachShadow)}constructor(callback){this._isObserving=!1,this._callbackWrapper=(mutations,observer)=>{for(const mutation of mutations)if("childList"===mutation.type){const removed=mutation.removedNodes,added=mutation.addedNodes;for(let i=0;i<removed.length;i++)this._walkShadows(removed[i],!0);for(let i=0;i<added.length;i++)this._walkShadows(added[i])}this._callback(mutations,observer)},this._callback=callback,this._observer=new MutationObserver(this._callbackWrapper),this._subObservers=new Map}_addSubObserver(shadowRoot){if(this._options&&this._callback&&!this._subObservers.has(shadowRoot)&&this._options.subtree&&nodeContains(this._root,shadowRoot)){const subObserver=new MutationObserver(this._callbackWrapper);this._subObservers.set(shadowRoot,subObserver),this._isObserving&&subObserver.observe(shadowRoot,this._options),this._walkShadows(shadowRoot)}}disconnect(){this._isObserving=!1,delete this._options,ShadowMutationObserver._shadowObservers.delete(this);for(const subObserver of this._subObservers.values())subObserver.disconnect();this._subObservers.clear(),this._observer.disconnect()}observe(target,options){const doc=target.nodeType===Node.DOCUMENT_NODE?target:target.ownerDocument,win=null==doc?void 0:doc.defaultView;doc&&win&&(ShadowMutationObserver._overrideAttachShadow(win),ShadowMutationObserver._shadowObservers.add(this),this._root=target,this._options=options,this._isObserving=!0,this._observer.observe(target,options),this._walkShadows(target))}_walkShadows(target,remove){const doc=target.nodeType===Node.DOCUMENT_NODE?target:target.ownerDocument;if(!doc)return;if(target===doc)target=doc.body;else{const shadowRoot=target.shadowRoot;if(shadowRoot)return void this._addSubObserver(shadowRoot)}doc.createTreeWalker(target,NodeFilter.SHOW_ELEMENT,{acceptNode:node=>{if(node.nodeType===Node.ELEMENT_NODE)if(remove){const subObserver=this._subObservers.get(node);subObserver&&(subObserver.disconnect(),this._subObservers.delete(node))}else{const shadowRoot=node.shadowRoot;shadowRoot&&this._addSubObserver(shadowRoot)}return NodeFilter.FILTER_SKIP}}).nextNode()}takeRecords(){const records=this._observer.takeRecords();for(const subObserver of this._subObservers.values())records.push(...subObserver.takeRecords());return records}}ShadowMutationObserver._shadowObservers=new Set;class Tabster{constructor(tabster){this.keyboardNavigation=tabster.keyboardNavigation,this.focusedElement=tabster.focusedElement,this.focusable=tabster.focusable,this.root=tabster.root,this.uncontrolled=tabster.uncontrolled,this.core=tabster}}class TabsterCore{constructor(win,props){var _a,_b;this._forgetMemorizedElements=[],this._wrappers=new Set,this._initQueue=[],this._version="8.2.0",this._noop=!1,this.getWindow=()=>{if(!this._win)throw new Error("Using disposed Tabster.");return this._win},this._storage=function createWeakMap(win){const ctx=win.__tabsterInstanceContext;return new((null==ctx?void 0:ctx.basics.WeakMap)||WeakMap)}(win),this._win=win;const getWindow=this.getWindow;(null==props?void 0:props.DOMAPI)&&function setDOMAPI(domapi){for(const key of Object.keys(domapi))dom[key]=domapi[key]}({...props.DOMAPI}),this.keyboardNavigation=new KeyboardNavigationState(getWindow),this.focusedElement=new FocusedElementState(this,getWindow),this.focusable=new FocusableAPI(this),this.root=new RootAPI(this,null==props?void 0:props.autoRoot),this.uncontrolled=new UncontrolledAPI((null==props?void 0:props.checkUncontrolledCompletely)||(null==props?void 0:props.checkUncontrolledTrappingFocus)),this.controlTab=null===(_a=null==props?void 0:props.controlTab)||void 0===_a||_a,this.rootDummyInputs=!!(null==props?void 0:props.rootDummyInputs),this._dummyObserver=new DummyInputObserver(getWindow),this.getParent=null!==(_b=null==props?void 0:props.getParent)&&void 0!==_b?_b:dom.getParentNode,this.internal={stopObserver:()=>{this._unobserve&&(this._unobserve(),delete this._unobserve)},resumeObserver:syncState=>{if(!this._unobserve){const doc=getWindow().document;this._unobserve=function observeMutations(doc,tabster,updateTabsterByAttribute,syncState){if("undefined"==typeof MutationObserver)return()=>{};const getWindow=tabster.getWindow;let elementByUId;function updateTabsterElements(node,removed){elementByUId||(elementByUId=getInstanceContext(getWindow).elementByUId),processNode(node,removed);const walker=createElementTreeWalker(doc,node,(element=>processNode(element,removed)));if(walker)for(;walker.nextNode(););}function processNode(element,removed){var _a;if(!element.getAttribute)return NodeFilter.FILTER_SKIP;const uid=element.__tabsterElementUID;return uid&&elementByUId&&(removed?delete elementByUId[uid]:null!==(_a=elementByUId[uid])&&void 0!==_a||(elementByUId[uid]=new WeakHTMLElement(getWindow,element))),(getTabsterOnElement(tabster,element)||element.hasAttribute(TABSTER_ATTRIBUTE_NAME))&&updateTabsterByAttribute(tabster,element,removed),NodeFilter.FILTER_SKIP}const observer=dom.createMutationObserver((mutations=>{var _a,_b,_c,_d,_e;const removedNodes=new Set;for(const mutation of mutations){const target=mutation.target,removed=mutation.removedNodes,added=mutation.addedNodes;if("attributes"===mutation.type)mutation.attributeName===TABSTER_ATTRIBUTE_NAME&&(removedNodes.has(target)||updateTabsterByAttribute(tabster,target));else{for(let i=0;i<removed.length;i++){const removedNode=removed[i];removedNodes.add(removedNode),updateTabsterElements(removedNode,!0),null===(_b=(_a=tabster._dummyObserver).domChanged)||void 0===_b||_b.call(_a,target)}for(let i=0;i<added.length;i++)updateTabsterElements(added[i]),null===(_d=(_c=tabster._dummyObserver).domChanged)||void 0===_d||_d.call(_c,target)}}removedNodes.clear(),null===(_e=tabster.modalizer)||void 0===_e||_e.hiddenUpdate()}));return syncState&&updateTabsterElements(getWindow().document.body),observer.observe(doc,{childList:!0,subtree:!0,attributes:!0,attributeFilter:[TABSTER_ATTRIBUTE_NAME]}),()=>{observer.disconnect()}}(doc,this,updateTabsterByAttribute,syncState)}}},startFakeWeakRefsCleanup(getWindow),this.queueInit((()=>{this.internal.resumeObserver(!0)}))}_mergeProps(props){var _a;props&&(this.getParent=null!==(_a=props.getParent)&&void 0!==_a?_a:this.getParent)}createTabster(noRefCount,props){const wrapper=new Tabster(this);return noRefCount||this._wrappers.add(wrapper),this._mergeProps(props),wrapper}disposeTabster(wrapper,allInstances){allInstances?this._wrappers.clear():this._wrappers.delete(wrapper),0===this._wrappers.size&&this.dispose()}dispose(){var _a,_b,_c,_d,_e,_f,_g,_h;this.internal.stopObserver();const win=this._win;null==win||win.clearTimeout(this._initTimer),delete this._initTimer,this._initQueue=[],this._forgetMemorizedElements=[],win&&this._forgetMemorizedTimer&&(win.clearTimeout(this._forgetMemorizedTimer),delete this._forgetMemorizedTimer),null===(_a=this.outline)||void 0===_a||_a.dispose(),null===(_b=this.crossOrigin)||void 0===_b||_b.dispose(),null===(_c=this.deloser)||void 0===_c||_c.dispose(),null===(_d=this.groupper)||void 0===_d||_d.dispose(),null===(_e=this.mover)||void 0===_e||_e.dispose(),null===(_f=this.modalizer)||void 0===_f||_f.dispose(),null===(_g=this.observedElement)||void 0===_g||_g.dispose(),null===(_h=this.restorer)||void 0===_h||_h.dispose(),this.keyboardNavigation.dispose(),this.focusable.dispose(),this.focusedElement.dispose(),this.root.dispose(),this._dummyObserver.dispose(),function stopFakeWeakRefsCleanupAndClearStorage(getWindow){const context=getInstanceContext(getWindow);context.fakeWeakRefsStarted=!1,context.fakeWeakRefsTimer&&(getWindow().clearTimeout(context.fakeWeakRefsTimer),context.fakeWeakRefsTimer=void 0,context.fakeWeakRefs=[])}(this.getWindow),clearElementCache(this.getWindow),this._storage=new WeakMap,this._wrappers.clear(),win&&(!function disposeInstanceContext(win){const ctx=win.__tabsterInstanceContext;ctx&&(ctx.elementByUId={},delete ctx.WeakRef,ctx.containerBoundingRectCache={},ctx.containerBoundingRectCacheTimer&&win.clearTimeout(ctx.containerBoundingRectCacheTimer),ctx.fakeWeakRefsTimer&&win.clearTimeout(ctx.fakeWeakRefsTimer),ctx.fakeWeakRefs=[],delete win.__tabsterInstanceContext)}(win),delete win.__tabsterInstance,delete this._win)}storageEntry(element,addremove){const storage=this._storage;let entry=storage.get(element);return entry?!1===addremove&&0===Object.keys(entry).length&&storage.delete(element):!0===addremove&&(entry={},storage.set(element,entry)),entry}forceCleanup(){this._win&&(this._forgetMemorizedElements.push(this._win.document.body),this._forgetMemorizedTimer||(this._forgetMemorizedTimer=this._win.setTimeout((()=>{delete this._forgetMemorizedTimer;for(let el=this._forgetMemorizedElements.shift();el;el=this._forgetMemorizedElements.shift())clearElementCache(this.getWindow,el),FocusedElementState.forgetMemorized(this.focusedElement,el)}),0),cleanupFakeWeakRefs(this.getWindow,!0)))}queueInit(callback){var _a;this._win&&(this._initQueue.push(callback),this._initTimer||(this._initTimer=null===(_a=this._win)||void 0===_a?void 0:_a.setTimeout((()=>{delete this._initTimer,this.drainInitQueue()}),0)))}drainInitQueue(){if(!this._win)return;const queue=this._initQueue;this._initQueue=[],queue.forEach((callback=>callback()))}}function createTabster(win,props){let tabster=getCurrentTabster(win);return tabster?tabster.createTabster(!1,props):(tabster=new TabsterCore(win,props),win.__tabsterInstance=tabster,tabster.createTabster())}function getGroupper(tabster){const tabsterCore=tabster.core;return tabsterCore.groupper||(tabsterCore.groupper=new GroupperAPI(tabsterCore,tabsterCore.getWindow)),tabsterCore.groupper}function getMover(tabster){const tabsterCore=tabster.core;return tabsterCore.mover||(tabsterCore.mover=new MoverAPI(tabsterCore,tabsterCore.getWindow)),tabsterCore.mover}function getModalizer(tabster,alwaysAccessibleSelector,accessibleCheck){const tabsterCore=tabster.core;return tabsterCore.modalizer||(tabsterCore.modalizer=new ModalizerAPI(tabsterCore,alwaysAccessibleSelector,accessibleCheck)),tabsterCore.modalizer}function getRestorer(tabster){const tabsterCore=tabster.core;return tabsterCore.restorer||(tabsterCore.restorer=new RestorerAPI(tabsterCore)),tabsterCore.restorer}function disposeTabster(tabster,allInstances){tabster.core.disposeTabster(tabster,allInstances)}function getCurrentTabster(win){return win.__tabsterInstance}}}]);